{"ast":null,"code":"import { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, RGBFormat, DoubleSide, BufferAttribute, MathUtils, InterpolateDiscrete, Matrix4, Scene, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\n\nconst GLTFExporter = (() => {\n  function GLTFExporter() {\n    this.pluginCallbacks = [];\n    this.register(writer => new GLTFLightExtension(writer));\n    this.register(writer => new GLTFMaterialsUnlitExtension(writer));\n    this.register(writer => new GLTFMaterialsPBRSpecularGlossiness(writer));\n  }\n\n  GLTFExporter.prototype = {\n    constructor: GLTFExporter,\n    register: function (callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n\n      return this;\n    },\n    unregister: function (callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Parse scenes and generate GLTF output\r\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n     * @param  {Function} onDone  Callback on completed\r\n     * @param  {Object} options options\r\n     */\n    parse: function (input, onDone, options) {\n      const writer = new GLTFWriter();\n      const plugins = [];\n\n      for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options);\n    }\n  }; //------------------------------------------------------------------------------\n  // Constants\n  //------------------------------------------------------------------------------\n\n  const WEBGL_CONSTANTS = {\n    POINTS: 0x0000,\n    LINES: 0x0001,\n    LINE_LOOP: 0x0002,\n    LINE_STRIP: 0x0003,\n    TRIANGLES: 0x0004,\n    TRIANGLE_STRIP: 0x0005,\n    TRIANGLE_FAN: 0x0006,\n    UNSIGNED_BYTE: 0x1401,\n    UNSIGNED_SHORT: 0x1403,\n    FLOAT: 0x1406,\n    UNSIGNED_INT: 0x1405,\n    ARRAY_BUFFER: 0x8892,\n    ELEMENT_ARRAY_BUFFER: 0x8893,\n    NEAREST: 0x2600,\n    LINEAR: 0x2601,\n    NEAREST_MIPMAP_NEAREST: 0x2700,\n    LINEAR_MIPMAP_NEAREST: 0x2701,\n    NEAREST_MIPMAP_LINEAR: 0x2702,\n    LINEAR_MIPMAP_LINEAR: 0x2703,\n    CLAMP_TO_EDGE: 33071,\n    MIRRORED_REPEAT: 33648,\n    REPEAT: 10497\n  };\n  const THREE_TO_WEBGL = {};\n  THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\n  THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\n  THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\n  THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\n  THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\n  THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n  THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\n  THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\n  THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n  const PATH_PROPERTIES = {\n    scale: 'scale',\n    position: 'translation',\n    quaternion: 'rotation',\n    morphTargetInfluences: 'weights'\n  }; // GLB constants\n  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n  const GLB_HEADER_BYTES = 12;\n  const GLB_HEADER_MAGIC = 0x46546c67;\n  const GLB_VERSION = 2;\n  const GLB_CHUNK_PREFIX_BYTES = 8;\n  const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\n  const GLB_CHUNK_TYPE_BIN = 0x004e4942; //------------------------------------------------------------------------------\n  // Utility functions\n  //------------------------------------------------------------------------------\n\n  /**\r\n   * Compare two arrays\r\n   * @param  {Array} array1 Array 1 to compare\r\n   * @param  {Array} array2 Array 2 to compare\r\n   * @return {Boolean}        Returns true if both arrays are equal\r\n   */\n\n  function equalArray(array1, array2) {\n    return array1.length === array2.length && array1.every((element, index) => element === array2[index]);\n  }\n  /**\r\n   * Converts a string to an ArrayBuffer.\r\n   * @param  {string} text\r\n   * @return {ArrayBuffer}\r\n   */\n\n\n  function stringToArrayBuffer(text) {\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(text).buffer;\n    }\n\n    const array = new Uint8Array(new ArrayBuffer(text.length));\n\n    for (let i = 0, il = text.length; i < il; i++) {\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n      array[i] = value > 0xff ? 0x20 : value;\n    }\n\n    return array.buffer;\n  }\n  /**\r\n   * Is identity matrix\r\n   *\r\n   * @param {Matrix4} matrix\r\n   * @returns {Boolean} Returns true, if parameter is identity matrix\r\n   */\n\n\n  function isIdentityMatrix(matrix) {\n    return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n  /**\r\n   * Get the min and max vectors from the given attribute\r\n   * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\r\n   * @param  {Integer} start\r\n   * @param  {Integer} count\r\n   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\r\n   */\n\n\n  function getMinMax(attribute, start, count) {\n    const output = {\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n    };\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        output.min[a] = Math.min(output.min[a], value);\n        output.max[a] = Math.max(output.max[a], value);\n      }\n    }\n\n    return output;\n  }\n  /**\r\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\r\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\r\n   *\r\n   * @param {Integer} bufferSize The size the original buffer.\r\n   * @returns {Integer} new buffer size with required padding.\r\n   *\r\n   */\n\n\n  function getPaddedBufferSize(bufferSize) {\n    return Math.ceil(bufferSize / 4) * 4;\n  }\n  /**\r\n   * Returns a buffer aligned to 4-byte boundary.\r\n   *\r\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\r\n   * @param {Integer} paddingByte (Optional)\r\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\r\n   */\n\n\n  function getPaddedArrayBuffer(arrayBuffer, paddingByte) {\n    paddingByte = paddingByte || 0;\n    const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n\n    if (paddedLength !== arrayBuffer.byteLength) {\n      const array = new Uint8Array(paddedLength);\n      array.set(new Uint8Array(arrayBuffer));\n\n      if (paddingByte !== 0) {\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n          array[i] = paddingByte;\n        }\n      }\n\n      return array.buffer;\n    }\n\n    return arrayBuffer;\n  }\n\n  let cachedCanvas = null;\n  /**\r\n   * Writer\r\n   */\n\n  function GLTFWriter() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n  }\n\n  GLTFWriter.prototype = {\n    constructor: GLTFWriter,\n    setPlugins: function (plugins) {\n      this.plugins = plugins;\n    },\n\n    /**\r\n     * Parse scenes and generate GLTF output\r\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n     * @param  {Function} onDone  Callback on completed\r\n     * @param  {Object} options options\r\n     */\n    write: function (input, onDone, options) {\n      this.options = Object.assign({}, {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        truncateDrawRange: true,\n        embedImages: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      }, options);\n\n      if (this.options.animations.length > 0) {\n        // Only TRS properties, and not matrices, may be targeted by animation.\n        this.options.trs = true;\n      }\n\n      this.processInput(input);\n      const writer = this;\n      Promise.all(this.pending).then(() => {\n        const buffers = writer.buffers;\n        const json = writer.json;\n        const options = writer.options;\n        const extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n        const blob = new Blob(buffers, {\n          type: 'application/octet-stream'\n        }); // Declare extensions.\n\n        const extensionsUsedList = Object.keys(extensionsUsed);\n        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n        if (options.binary === true) {\n          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n          var reader = new window.FileReader();\n          reader.readAsArrayBuffer(blob);\n\n          reader.onloadend = () => {\n            // Binary chunk.\n            const binaryChunk = getPaddedArrayBuffer(reader.result);\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n            const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\n            const headerView = new DataView(header);\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n            headerView.setUint32(4, GLB_VERSION, true);\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n            headerView.setUint32(8, totalByteLength, true);\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n              type: 'application/octet-stream'\n            });\n            const glbReader = new window.FileReader();\n            glbReader.readAsArrayBuffer(glbBlob);\n\n            glbReader.onloadend = () => {\n              onDone(glbReader.result);\n            };\n          };\n        } else {\n          if (json.buffers && json.buffers.length > 0) {\n            var reader = new window.FileReader();\n            reader.readAsDataURL(blob);\n\n            reader.onloadend = () => {\n              const base64data = reader.result;\n              json.buffers[0].uri = base64data;\n              onDone(json);\n            };\n          } else {\n            onDone(json);\n          }\n        }\n      });\n    },\n\n    /**\r\n     * Serializes a userData.\r\n     *\r\n     * @param {THREE.Object3D|THREE.Material} object\r\n     * @param {Object} objectDef\r\n     */\n    serializeUserData: function (object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      const options = this.options;\n      const extensionsUsed = this.extensionsUsed;\n\n      try {\n        const json = JSON.parse(JSON.stringify(object.userData));\n\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n          for (let extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n\n          delete json.gltfExtensions;\n        }\n\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        console.warn(`THREE.GLTFExporter: userData of '${object.name}' won't be serialized because of JSON.stringify error - ${error.message}`);\n      }\n    },\n\n    /**\r\n     * Assign and return a temporal unique id for an object\r\n     * especially which doesn't have .uuid\r\n     * @param  {Object} object\r\n     * @return {Integer}\r\n     */\n    getUID: function (object) {\n      if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n      return this.uids.get(object);\n    },\n\n    /**\r\n     * Checks if normal attribute values are normalized.\r\n     *\r\n     * @param {BufferAttribute} normal\r\n     * @returns {Boolean}\r\n     */\n    isNormalizedNormalAttribute: function (normal) {\n      const cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      const v = new Vector3();\n\n      for (let i = 0, il = normal.count; i < il; i++) {\n        // 0.0005 is from glTF-validator\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n      }\n\n      return true;\n    },\n\n    /**\r\n     * Creates normalized normal buffer attribute.\r\n     *\r\n     * @param {BufferAttribute} normal\r\n     * @returns {BufferAttribute}\r\n     *\r\n     */\n    createNormalizedNormalAttribute: function (normal) {\n      const cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      const attribute = normal.clone();\n      const v = new Vector3();\n\n      for (let i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          // if values can't be normalized set (1, 0, 0)\n          v.setX(1.0);\n        } else {\n          v.normalize();\n        }\n\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    },\n\n    /**\r\n     * Applies a texture transform, if present, to the map definition. Requires\r\n     * the KHR_texture_transform extension.\r\n     *\r\n     * @param {Object} mapDef\r\n     * @param {THREE.Texture} texture\r\n     */\n    applyTextureTransform: function (mapDef, texture) {\n      let didTransform = false;\n      const transformDef = {};\n\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\n        this.extensionsUsed['KHR_texture_transform'] = true;\n      }\n    },\n\n    /**\r\n     * Process a buffer to append to the default one.\r\n     * @param  {ArrayBuffer} buffer\r\n     * @return {Integer}\r\n     */\n    processBuffer: function (buffer) {\n      const json = this.json;\n      const buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }]; // All buffers are merged before export.\n\n      buffers.push(buffer);\n      return 0;\n    },\n\n    /**\r\n     * Process and generate a BufferView\r\n     * @param  {BufferAttribute} attribute\r\n     * @param  {number} componentType\r\n     * @param  {number} start\r\n     * @param  {number} count\r\n     * @param  {number} target (Optional) Target usage of the BufferView\r\n     * @return {Object}\r\n     */\n    processBufferView: function (attribute, componentType, start, count, target) {\n      const json = this.json;\n      if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n      let componentSize;\n\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n        componentSize = 1;\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n        componentSize = 2;\n      } else {\n        componentSize = 4;\n      }\n\n      const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      const dataView = new DataView(new ArrayBuffer(byteLength));\n      let offset = 0;\n\n      for (let i = start; i < start + count; i++) {\n        for (let a = 0; a < attribute.itemSize; a++) {\n          let value;\n\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n\n          offset += componentSize;\n        }\n      }\n\n      const bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength\n      };\n      if (target !== undefined) bufferViewDef.target = target;\n\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        // Only define byteStride for vertex attributes.\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n      const output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    },\n\n    /**\r\n     * Process and generate a BufferView from an image Blob.\r\n     * @param {Blob} blob\r\n     * @return {Promise<Integer>}\r\n     */\n    processBufferViewImage: function (blob) {\n      const writer = this;\n      const json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(resolve => {\n        const reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = () => {\n          const buffer = getPaddedArrayBuffer(reader.result);\n          const bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        };\n      });\n    },\n\n    /**\r\n     * Process attribute to generate an accessor\r\n     * @param  {BufferAttribute} attribute Attribute to process\r\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\r\n     * @param  {Integer} start (Optional)\r\n     * @param  {Integer} count (Optional)\r\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\r\n     */\n    processAccessor: function (attribute, geometry, start, count) {\n      const options = this.options;\n      const json = this.json;\n      const types = {\n        1: 'SCALAR',\n        2: 'VEC2',\n        3: 'VEC3',\n        4: 'VEC4',\n        16: 'MAT4'\n      };\n      let componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n      }\n\n      if (start === undefined) start = 0;\n      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n        const end = start + count;\n        const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n        start = Math.max(start, geometry.drawRange.start);\n        count = Math.min(end, end2) - start;\n        if (count < 0) count = 0;\n      } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n      if (count === 0) return null;\n      const minMax = getMinMax(attribute, start, count);\n      let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n      // animation samplers, target must not be set.\n\n      if (geometry !== undefined) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      const accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType,\n        count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized === true) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    },\n\n    /**\r\n     * Process image\r\n     * @param  {Image} image to process\r\n     * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\r\n     * @param  {Boolean} flipY before writing out the image\r\n     * @return {Integer}     Index of the processed texture in the \"images\" array\r\n     */\n    processImage: function (image, format, flipY) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n      const key = `${mimeType}:flipY/${flipY.toString()}`;\n      if (cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      const imageDef = {\n        mimeType\n      };\n\n      if (options.embedImages) {\n        const canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        const ctx = canvas.getContext('2d');\n\n        if (flipY === true) {\n          ctx.translate(0, canvas.height);\n          ctx.scale(1, -1);\n        }\n\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } else {\n          if (format !== RGBAFormat && format !== RGBFormat) {\n            console.error('GLTFExporter: Only RGB and RGBA formats are supported.');\n          }\n\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n          }\n\n          let data = image.data;\n\n          if (format === RGBFormat) {\n            data = new Uint8ClampedArray(image.height * image.width * 4);\n\n            for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {\n              data[i + 0] = image.data[j + 0];\n              data[i + 1] = image.data[j + 1];\n              data[i + 2] = image.data[j + 2];\n              data[i + 3] = 255;\n            }\n          }\n\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        }\n\n        if (options.binary === true) {\n          pending.push(new Promise(resolve => {\n            canvas.toBlob(blob => {\n              writer.processBufferViewImage(blob).then(bufferViewIndex => {\n                imageDef.bufferView = bufferViewIndex;\n                resolve();\n              });\n            }, mimeType);\n          }));\n        } else {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        }\n      } else {\n        imageDef.uri = image.src;\n      }\n\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    },\n\n    /**\r\n     * Process sampler\r\n     * @param  {Texture} map Texture to process\r\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\r\n     */\n    processSampler: function (map) {\n      const json = this.json;\n      if (!json.samplers) json.samplers = [];\n      const samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    },\n\n    /**\r\n     * Process texture\r\n     * @param  {Texture} map Map to process\r\n     * @return {Integer} Index of the processed texture in the \"textures\" array\r\n     */\n    processTexture: function (map) {\n      const cache = this.cache;\n      const json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      const textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY)\n      };\n      if (map.name) textureDef.name = map.name;\n\n      this._invokeAll(ext => {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n\n      const index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    },\n\n    /**\r\n     * Process material\r\n     * @param  {THREE.Material} material Material to process\r\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\r\n     */\n    processMaterial: function (material) {\n      const cache = this.cache;\n      const json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n\n      if (material.isShaderMaterial) {\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n        return null;\n      }\n\n      if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n      const materialDef = {\n        pbrMetallicRoughness: {}\n      };\n\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n      } // pbrMetallicRoughness.baseColorFactor\n\n\n      const color = material.color.toArray().concat([material.opacity]);\n\n      if (!equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n\n      if (material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n      if (material.metalnessMap || material.roughnessMap) {\n        if (material.metalnessMap === material.roughnessMap) {\n          const metalRoughMapDef = {\n            index: this.processTexture(material.metalnessMap)\n          };\n          this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n          materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n        } else {\n          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n        }\n      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n      if (material.map) {\n        const baseColorMapDef = {\n          index: this.processTexture(material.map)\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n\n      if (material.emissive) {\n        // emissiveFactor\n        const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\n\n        if (!equalArray(emissive, [0, 0, 0])) {\n          materialDef.emissiveFactor = emissive;\n        } // emissiveTexture\n\n\n        if (material.emissiveMap) {\n          const emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap)\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      } // normalTexture\n\n\n      if (material.normalMap) {\n        const normalMapDef = {\n          index: this.processTexture(material.normalMap)\n        };\n\n        if (material.normalScale && material.normalScale.x !== -1) {\n          if (material.normalScale.x !== material.normalScale.y) {\n            console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\n          }\n\n          normalMapDef.scale = material.normalScale.x;\n        }\n\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      } // occlusionTexture\n\n\n      if (material.aoMap) {\n        const occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: 1\n        };\n\n        if (material.aoMapIntensity !== 1.0) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      } // alphaMode\n\n\n      if (material.transparent) {\n        materialDef.alphaMode = 'BLEND';\n      } else {\n        if (material.alphaTest > 0.0) {\n          materialDef.alphaMode = 'MASK';\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      } // doubleSided\n\n\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== '') materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n\n      this._invokeAll(ext => {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n\n      const index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    },\n\n    /**\r\n     * Process mesh\r\n     * @param  {THREE.Mesh} mesh Mesh to process\r\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\r\n     */\n    processMesh: function (mesh) {\n      const cache = this.cache;\n      const json = this.json;\n      const meshCacheKeyParts = [mesh.geometry.uuid];\n\n      if (Array.isArray(mesh.material)) {\n        for (let i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n\n      const meshCacheKey = meshCacheKeyParts.join(':');\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      const geometry = mesh.geometry;\n      let mode; // Use the correct mode\n\n      if (mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      const meshDef = {};\n      const attributes = {};\n      const primitives = [];\n      const targets = []; // Conversion between attributes names in threejs and gltf spec\n\n      const nameConversion = {\n        uv: 'TEXCOORD_0',\n        uv2: 'TEXCOORD_1',\n        color: 'COLOR_0',\n        skinWeight: 'WEIGHTS_0',\n        skinIndex: 'JOINTS_0'\n      };\n      const originalNormal = geometry.getAttribute('normal');\n\n      if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n      } // @QUESTION Detect if .vertexColors = true?\n      // For every attribute create an accessor\n\n\n      let modifiedAttribute = null;\n\n      for (let attributeName in geometry.attributes) {\n        // Ignore morph target attributes, which are exported later.\n        if (attributeName.substr(0, 5) === 'morph') continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n        // listed in the spec; non-spec attributes are considered custom.\n\n        const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = `_${attributeName}`;\n\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n        modifiedAttribute = null;\n        const array = attribute.array;\n\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n\n        const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n\n        if (accessor !== null) {\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n      if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n        const weights = [];\n        const targetNames = [];\n        const reverseDictionary = {};\n\n        if (mesh.morphTargetDictionary !== undefined) {\n          for (let key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n\n        for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n          const target = {};\n          let warned = false;\n\n          for (let attributeName in geometry.morphAttributes) {\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n            // Three.js doesn't support TANGENT yet.\n            if (attributeName !== 'position' && attributeName !== 'normal') {\n              if (!warned) {\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n                warned = true;\n              }\n\n              continue;\n            }\n\n            var attribute = geometry.morphAttributes[attributeName][i];\n            const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n            //\n            // glTF 2.0 Specification:\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n            const baseAttribute = geometry.attributes[attributeName];\n\n            if (cache.attributes.has(this.getUID(attribute))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n              continue;\n            } // Clones attribute not to override\n\n\n            const relativeAttribute = attribute.clone();\n\n            if (!geometry.morphTargetsRelative) {\n              for (let j = 0, jl = attribute.count; j < jl; j++) {\n                relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n              }\n            }\n\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n            cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n          }\n\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[i]);\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n        }\n\n        meshDef.weights = weights;\n\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n\n      const isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      const materials = isMultiMaterial ? mesh.material : [mesh.material];\n      const groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: undefined,\n        count: undefined\n      }];\n\n      for (let i = 0, il = groups.length; i < il; i++) {\n        const primitive = {\n          mode,\n          attributes\n        };\n        this.serializeUserData(geometry, primitive);\n        if (targets.length > 0) primitive.targets = targets;\n\n        if (geometry.index !== null) {\n          let cacheKey = this.getUID(geometry.index);\n\n          if (groups[i].start !== undefined || groups[i].count !== undefined) {\n            cacheKey += `:${groups[i].start}:${groups[i].count}`;\n          }\n\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n\n          if (primitive.indices === null) delete primitive.indices;\n        }\n\n        const material = this.processMaterial(materials[groups[i].materialIndex]);\n        if (material !== null) primitive.material = material;\n        primitives.push(primitive);\n      }\n\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n\n      this._invokeAll(ext => {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n\n      const index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    },\n\n    /**\r\n     * Process camera\r\n     * @param  {THREE.Camera} camera Camera to process\r\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\r\n     */\n    processCamera: function (camera) {\n      const json = this.json;\n      if (!json.cameras) json.cameras = [];\n      const isOrtho = camera.isOrthographicCamera;\n      const cameraDef = {\n        type: isOrtho ? 'orthographic' : 'perspective'\n      };\n\n      if (isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } // Question: Is saving \"type\" as name intentional?\n\n\n      if (camera.name !== '') cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    },\n\n    /**\r\n     * Creates glTF animation entry from AnimationClip object.\r\n     *\r\n     * Status:\r\n     * - Only properties listed in PATH_PROPERTIES may be animated.\r\n     *\r\n     * @param {THREE.AnimationClip} clip\r\n     * @param {THREE.Object3D} root\r\n     * @return {number|null}\r\n     */\n    processAnimation: function (clip, root) {\n      const json = this.json;\n      const nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      const tracks = clip.tracks;\n      const channels = [];\n      const samplers = [];\n\n      for (let i = 0; i < tracks.length; ++i) {\n        const track = tracks[i];\n        const trackBinding = PropertyBinding.parseTrackName(track.name);\n        let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n        if (trackBinding.objectName === 'bones') {\n          if (trackNode.isSkinnedMesh === true) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = undefined;\n          }\n        }\n\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n\n        const inputItemSize = 1;\n        let outputItemSize = track.values.length / track.times.length;\n\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n\n        let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n        // valid value from .getInterpolation().\n\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n          // but needs to be stored as VEC3 so dividing by 3 here.\n\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = 'STEP';\n        } else {\n          interpolation = 'LINEAR';\n        }\n\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n\n      json.animations.push({\n        name: clip.name || `clip_${json.animations.length}`,\n        samplers,\n        channels\n      });\n      return json.animations.length - 1;\n    },\n\n    /**\r\n     * @param {THREE.Object3D} object\r\n     * @return {number|null}\r\n     */\n    processSkin: function (object) {\n      const json = this.json;\n      const nodeMap = this.nodeMap;\n      const node = json.nodes[nodeMap.get(object)];\n      const skeleton = object.skeleton;\n      if (skeleton === undefined) return null;\n      const rootJoint = object.skeleton.bones[0];\n      if (rootJoint === undefined) return null;\n      const joints = [];\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      const temporaryBoneInverse = new Matrix4();\n\n      for (let i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n\n      if (json.skins === undefined) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      const skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    },\n\n    /**\r\n     * Process Object3D node\r\n     * @param  {THREE.Object3D} node Object3D to processNode\r\n     * @return {Integer} Index of the node in the nodes list\r\n     */\n    processNode: function (object) {\n      const json = this.json;\n      const options = this.options;\n      const nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      const nodeDef = {};\n\n      if (options.trs) {\n        const rotation = object.quaternion.toArray();\n        const position = object.position.toArray();\n        const scale = object.scale.toArray();\n\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n\n        if (!equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n\n        if (!equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n\n        if (isIdentityMatrix(object.matrix) === false) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n      if (object.name !== '') nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n\n      if (object.isMesh || object.isLine || object.isPoints) {\n        const meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n\n      if (object.isSkinnedMesh) this.skins.push(object);\n\n      if (object.children.length > 0) {\n        const children = [];\n\n        for (let i = 0, l = object.children.length; i < l; i++) {\n          const child = object.children[i];\n\n          if (child.visible || options.onlyVisible === false) {\n            var nodeIndex = this.processNode(child);\n            if (nodeIndex !== null) children.push(nodeIndex);\n          }\n        }\n\n        if (children.length > 0) nodeDef.children = children;\n      }\n\n      this._invokeAll(ext => {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    },\n\n    /**\r\n     * Process Scene\r\n     * @param  {Scene} node Scene to process\r\n     */\n    processScene: function (scene) {\n      const json = this.json;\n      const options = this.options;\n\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n\n      const sceneDef = {};\n      if (scene.name !== '') sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      const nodes = [];\n\n      for (let i = 0, l = scene.children.length; i < l; i++) {\n        const child = scene.children[i];\n\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    },\n\n    /**\r\n     * Creates a Scene to hold a list of objects and parse it\r\n     * @param  {Array} objects List of objects to process\r\n     */\n    processObjects: function (objects) {\n      const scene = new Scene();\n      scene.name = 'AuxScene';\n\n      for (let i = 0; i < objects.length; i++) {\n        // We push directly to children instead of calling `add` to prevent\n        // modify the .parent and break its original scene and hierarchy\n        scene.children.push(objects[i]);\n      }\n\n      this.processScene(scene);\n    },\n\n    /**\r\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\r\n     */\n    processInput: function (input) {\n      const options = this.options;\n      input = input instanceof Array ? input : [input];\n\n      this._invokeAll(ext => {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n\n      const objectsWithoutScene = [];\n\n      for (let i = 0; i < input.length; i++) {\n        if (input[i] instanceof Scene) {\n          this.processScene(input[i]);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n      for (let i = 0; i < this.skins.length; ++i) {\n        this.processSkin(this.skins[i]);\n      }\n\n      for (let i = 0; i < options.animations.length; ++i) {\n        this.processAnimation(options.animations[i], input[0]);\n      }\n\n      this._invokeAll(ext => {\n        ext.afterParse && ext.afterParse(input);\n      });\n    },\n    _invokeAll: function (func) {\n      for (let i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    }\n  };\n  /**\r\n   * Punctual Lights Extension\r\n   *\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n   */\n\n  function GLTFLightExtension(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  GLTFLightExtension.prototype = {\n    constructor: GLTFLightExtension,\n    writeNode: function (light, nodeDef) {\n      if (!light.isLight) return;\n\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n        return;\n      }\n\n      const writer = this.writer;\n      const json = writer.json;\n      const extensionsUsed = writer.extensionsUsed;\n      const lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n\n      if (light.isDirectionalLight) {\n        lightDef.type = 'directional';\n      } else if (light.isPointLight) {\n        lightDef.type = 'point';\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light.isSpotLight) {\n        lightDef.type = 'spot';\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n\n      if (light.decay !== undefined && light.decay !== 2) {\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n      }\n\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n      }\n\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n\n      const lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  };\n  /**\r\n   * Unlit Materials Extension\r\n   *\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n   */\n\n  function GLTFMaterialsUnlitExtension(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  GLTFMaterialsUnlitExtension.prototype = {\n    constructor: GLTFMaterialsUnlitExtension,\n    writeMaterial: function (material, materialDef) {\n      if (!material.isMeshBasicMaterial) return;\n      const writer = this.writer;\n      const extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  };\n  /**\r\n   * Specular-Glossiness Extension\r\n   *\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n   */\n\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  GLTFMaterialsPBRSpecularGlossiness.prototype = {\n    constructor: GLTFMaterialsPBRSpecularGlossiness,\n    writeMaterial: function (material, materialDef) {\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\n      const writer = this.writer;\n      const extensionsUsed = writer.extensionsUsed;\n      const extensionDef = {};\n\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n      }\n\n      const specularFactor = [1, 1, 1];\n      material.specular.toArray(specularFactor, 0);\n      extensionDef.specularFactor = specularFactor;\n      extensionDef.glossinessFactor = material.glossiness;\n\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n      }\n\n      if (material.specularMap) {\n        const specularMapDef = {\n          index: writer.processTexture(material.specularMap)\n        };\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\n        extensionDef.specularGlossinessTexture = specularMapDef;\n      }\n\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  };\n  /**\r\n   * Static utility functions\r\n   */\n\n  GLTFExporter.Utils = {\n    insertKeyframe: function (track, time) {\n      const tolerance = 0.001; // 1ms\n\n      const valueSize = track.getValueSize();\n      const times = new track.TimeBufferType(track.times.length + 1);\n      const values = new track.ValueBufferType(track.values.length + valueSize);\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n      let index;\n\n      if (track.times.length === 0) {\n        times[0] = time;\n\n        for (let i = 0; i < valueSize; i++) {\n          values[i] = 0;\n        }\n\n        index = 0;\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance) return 0;\n        times[0] = time;\n        times.set(track.times, 1);\n        values.set(interpolant.evaluate(time), 0);\n        values.set(track.values, valueSize);\n        index = 0;\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1;\n        }\n\n        times[times.length - 1] = time;\n        times.set(track.times, 0);\n        values.set(track.values, 0);\n        values.set(interpolant.evaluate(time), track.values.length);\n        index = times.length - 1;\n      } else {\n        for (let i = 0; i < track.times.length; i++) {\n          if (Math.abs(track.times[i] - time) < tolerance) return i;\n\n          if (track.times[i] < time && track.times[i + 1] > time) {\n            times.set(track.times.slice(0, i + 1), 0);\n            times[i + 1] = time;\n            times.set(track.times.slice(i + 1), i + 2);\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n            index = i + 1;\n            break;\n          }\n        }\n      }\n\n      track.times = times;\n      track.values = values;\n      return index;\n    },\n    mergeMorphTargetTracks: function (clip, root) {\n      const tracks = [];\n      const mergedTracks = {};\n      const sourceTracks = clip.tracks;\n\n      for (let i = 0; i < sourceTracks.length; ++i) {\n        let sourceTrack = sourceTracks[i];\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n        if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n          // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n          tracks.push(sourceTrack);\n          continue;\n        }\n\n        if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            // This should never happen, because glTF morph target animations\n            // affect all targets already.\n            throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n          }\n\n          console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n          sourceTrack = sourceTrack.clone();\n          sourceTrack.setInterpolation(InterpolateLinear);\n        }\n\n        const targetCount = sourceTrackNode.morphTargetInfluences.length;\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n        if (targetIndex === undefined) {\n          throw new Error(`THREE.GLTFExporter: Morph target name not found: ${sourceTrackBinding.propertyIndex}`);\n        }\n\n        let mergedTrack; // If this is the first time we've seen this object, create a new\n        // track to store merged keyframe data for each morph target.\n\n        if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n          mergedTrack = sourceTrack.clone();\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j];\n          } // We need to take into consideration the intended target node\n          // of our original un-merged morphTarget animation.\n\n\n          mergedTrack.name = `${sourceTrackBinding.nodeName || ''}.morphTargetInfluences`;\n          mergedTrack.values = values;\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n          tracks.push(mergedTrack);\n          continue;\n        }\n\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n        mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n        // interpolated) value from the source track.\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n        } // For every existing keyframe of the source track, write a (possibly\n        // new) keyframe to the merged track. Values from the previous loop may\n        // be written again, but keyframes are de-duplicated.\n\n\n        for (let j = 0; j < sourceTrack.times.length; j++) {\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n        }\n      }\n\n      clip.tracks = tracks;\n      return clip;\n    }\n  };\n  return GLTFExporter;\n})();\n\nexport { GLTFExporter };","map":{"version":3,"sources":["C:/Users/samue/Documents/REACTworkspace/group-bank-web/node_modules/three-stdlib/exporters/GLTFExporter.js"],"names":["PropertyBinding","InterpolateLinear","Vector3","RGBAFormat","RGBFormat","DoubleSide","BufferAttribute","MathUtils","InterpolateDiscrete","Matrix4","Scene","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","GLTFExporter","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsPBRSpecularGlossiness","prototype","constructor","callback","indexOf","push","unregister","splice","parse","input","onDone","options","GLTFWriter","plugins","i","il","length","setPlugins","write","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","window","TextEncoder","undefined","encode","buffer","array","Uint8Array","ArrayBuffer","value","charCodeAt","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","min","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","getX","getY","getZ","getW","Math","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","set","cachedCanvas","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","Object","assign","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","Promise","all","then","blob","Blob","type","extensionsUsedList","keys","size","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","console","warn","name","message","getUID","has","get","isNormalizedNormalAttribute","normal","v","abs","fromBufferAttribute","createNormalizedNormalAttribute","clone","x","y","z","setX","normalize","setXYZ","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","processBuffer","processBufferView","componentType","target","bufferViews","componentSize","dataView","setFloat32","setUint16","setUint8","bufferViewDef","byteStride","id","processBufferViewImage","resolve","processAccessor","geometry","types","Float32Array","Uint32Array","Uint16Array","Error","end","end2","drawRange","minMax","bufferViewTarget","bufferView","accessorDef","normalized","accessors","processImage","image","format","flipY","cachedImages","mimeType","key","toString","imageDef","canvas","document","createElement","width","height","ctx","getContext","translate","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","drawImage","data","Uint8ClampedArray","j","putImageData","ImageData","toBlob","bufferViewIndex","toDataURL","src","processSampler","map","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","processTexture","textureDef","sampler","source","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","metalnessMap","roughnessMap","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","multiplyScalar","emissiveIntensity","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterial","processMesh","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","meshDef","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","substr","toUpperCase","validVertexAttributes","test","accessor","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","jl","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","writeMesh","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","clip","root","Utils","mergeMorphTargetTracks","tracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","values","times","interpolation","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex","writeNode","processScene","scene","scenes","sceneDef","processObjects","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isGLTFSpecularGlossinessMaterial","extensionDef","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","diffuseTexture","specularMap","specularMapDef","specularGlossinessTexture","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","slice","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex"],"mappings":"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","sourcesContent":["import { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, RGBFormat, DoubleSide, BufferAttribute, MathUtils, InterpolateDiscrete, Matrix4, Scene, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\r\n\r\nconst GLTFExporter = (() => {\r\n  function GLTFExporter() {\r\n    this.pluginCallbacks = [];\r\n    this.register(writer => new GLTFLightExtension(writer));\r\n    this.register(writer => new GLTFMaterialsUnlitExtension(writer));\r\n    this.register(writer => new GLTFMaterialsPBRSpecularGlossiness(writer));\r\n  }\r\n\r\n  GLTFExporter.prototype = {\r\n    constructor: GLTFExporter,\r\n    register: function (callback) {\r\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\r\n        this.pluginCallbacks.push(callback);\r\n      }\r\n\r\n      return this;\r\n    },\r\n    unregister: function (callback) {\r\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\r\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Parse scenes and generate GLTF output\r\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n     * @param  {Function} onDone  Callback on completed\r\n     * @param  {Object} options options\r\n     */\r\n    parse: function (input, onDone, options) {\r\n      const writer = new GLTFWriter();\r\n      const plugins = [];\r\n\r\n      for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\r\n        plugins.push(this.pluginCallbacks[i](writer));\r\n      }\r\n\r\n      writer.setPlugins(plugins);\r\n      writer.write(input, onDone, options);\r\n    }\r\n  }; //------------------------------------------------------------------------------\r\n  // Constants\r\n  //------------------------------------------------------------------------------\r\n\r\n  const WEBGL_CONSTANTS = {\r\n    POINTS: 0x0000,\r\n    LINES: 0x0001,\r\n    LINE_LOOP: 0x0002,\r\n    LINE_STRIP: 0x0003,\r\n    TRIANGLES: 0x0004,\r\n    TRIANGLE_STRIP: 0x0005,\r\n    TRIANGLE_FAN: 0x0006,\r\n    UNSIGNED_BYTE: 0x1401,\r\n    UNSIGNED_SHORT: 0x1403,\r\n    FLOAT: 0x1406,\r\n    UNSIGNED_INT: 0x1405,\r\n    ARRAY_BUFFER: 0x8892,\r\n    ELEMENT_ARRAY_BUFFER: 0x8893,\r\n    NEAREST: 0x2600,\r\n    LINEAR: 0x2601,\r\n    NEAREST_MIPMAP_NEAREST: 0x2700,\r\n    LINEAR_MIPMAP_NEAREST: 0x2701,\r\n    NEAREST_MIPMAP_LINEAR: 0x2702,\r\n    LINEAR_MIPMAP_LINEAR: 0x2703,\r\n    CLAMP_TO_EDGE: 33071,\r\n    MIRRORED_REPEAT: 33648,\r\n    REPEAT: 10497\r\n  };\r\n  const THREE_TO_WEBGL = {};\r\n  THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\r\n  THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\r\n  THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\r\n  THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\r\n  THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\r\n  THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\r\n  THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\r\n  THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\r\n  THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\r\n  const PATH_PROPERTIES = {\r\n    scale: 'scale',\r\n    position: 'translation',\r\n    quaternion: 'rotation',\r\n    morphTargetInfluences: 'weights'\r\n  }; // GLB constants\r\n  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n\r\n  const GLB_HEADER_BYTES = 12;\r\n  const GLB_HEADER_MAGIC = 0x46546c67;\r\n  const GLB_VERSION = 2;\r\n  const GLB_CHUNK_PREFIX_BYTES = 8;\r\n  const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\r\n  const GLB_CHUNK_TYPE_BIN = 0x004e4942; //------------------------------------------------------------------------------\r\n  // Utility functions\r\n  //------------------------------------------------------------------------------\r\n\r\n  /**\r\n   * Compare two arrays\r\n   * @param  {Array} array1 Array 1 to compare\r\n   * @param  {Array} array2 Array 2 to compare\r\n   * @return {Boolean}        Returns true if both arrays are equal\r\n   */\r\n\r\n  function equalArray(array1, array2) {\r\n    return array1.length === array2.length && array1.every((element, index) => element === array2[index]);\r\n  }\r\n  /**\r\n   * Converts a string to an ArrayBuffer.\r\n   * @param  {string} text\r\n   * @return {ArrayBuffer}\r\n   */\r\n\r\n\r\n  function stringToArrayBuffer(text) {\r\n    if (window.TextEncoder !== undefined) {\r\n      return new TextEncoder().encode(text).buffer;\r\n    }\r\n\r\n    const array = new Uint8Array(new ArrayBuffer(text.length));\r\n\r\n    for (let i = 0, il = text.length; i < il; i++) {\r\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\r\n\r\n      array[i] = value > 0xff ? 0x20 : value;\r\n    }\r\n\r\n    return array.buffer;\r\n  }\r\n  /**\r\n   * Is identity matrix\r\n   *\r\n   * @param {Matrix4} matrix\r\n   * @returns {Boolean} Returns true, if parameter is identity matrix\r\n   */\r\n\r\n\r\n  function isIdentityMatrix(matrix) {\r\n    return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\r\n  }\r\n  /**\r\n   * Get the min and max vectors from the given attribute\r\n   * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\r\n   * @param  {Integer} start\r\n   * @param  {Integer} count\r\n   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\r\n   */\r\n\r\n\r\n  function getMinMax(attribute, start, count) {\r\n    const output = {\r\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\r\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\r\n    };\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      for (let a = 0; a < attribute.itemSize; a++) {\r\n        let value;\r\n\r\n        if (attribute.itemSize > 4) {\r\n          // no support for interleaved data for itemSize > 4\r\n          value = attribute.array[i * attribute.itemSize + a];\r\n        } else {\r\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\r\n        }\r\n\r\n        output.min[a] = Math.min(output.min[a], value);\r\n        output.max[a] = Math.max(output.max[a], value);\r\n      }\r\n    }\r\n\r\n    return output;\r\n  }\r\n  /**\r\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\r\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\r\n   *\r\n   * @param {Integer} bufferSize The size the original buffer.\r\n   * @returns {Integer} new buffer size with required padding.\r\n   *\r\n   */\r\n\r\n\r\n  function getPaddedBufferSize(bufferSize) {\r\n    return Math.ceil(bufferSize / 4) * 4;\r\n  }\r\n  /**\r\n   * Returns a buffer aligned to 4-byte boundary.\r\n   *\r\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\r\n   * @param {Integer} paddingByte (Optional)\r\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\r\n   */\r\n\r\n\r\n  function getPaddedArrayBuffer(arrayBuffer, paddingByte) {\r\n    paddingByte = paddingByte || 0;\r\n    const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\r\n\r\n    if (paddedLength !== arrayBuffer.byteLength) {\r\n      const array = new Uint8Array(paddedLength);\r\n      array.set(new Uint8Array(arrayBuffer));\r\n\r\n      if (paddingByte !== 0) {\r\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\r\n          array[i] = paddingByte;\r\n        }\r\n      }\r\n\r\n      return array.buffer;\r\n    }\r\n\r\n    return arrayBuffer;\r\n  }\r\n\r\n  let cachedCanvas = null;\r\n  /**\r\n   * Writer\r\n   */\r\n\r\n  function GLTFWriter() {\r\n    this.plugins = [];\r\n    this.options = {};\r\n    this.pending = [];\r\n    this.buffers = [];\r\n    this.byteOffset = 0;\r\n    this.buffers = [];\r\n    this.nodeMap = new Map();\r\n    this.skins = [];\r\n    this.extensionsUsed = {};\r\n    this.uids = new Map();\r\n    this.uid = 0;\r\n    this.json = {\r\n      asset: {\r\n        version: '2.0',\r\n        generator: 'THREE.GLTFExporter'\r\n      }\r\n    };\r\n    this.cache = {\r\n      meshes: new Map(),\r\n      attributes: new Map(),\r\n      attributesNormalized: new Map(),\r\n      materials: new Map(),\r\n      textures: new Map(),\r\n      images: new Map()\r\n    };\r\n  }\r\n\r\n  GLTFWriter.prototype = {\r\n    constructor: GLTFWriter,\r\n    setPlugins: function (plugins) {\r\n      this.plugins = plugins;\r\n    },\r\n\r\n    /**\r\n     * Parse scenes and generate GLTF output\r\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n     * @param  {Function} onDone  Callback on completed\r\n     * @param  {Object} options options\r\n     */\r\n    write: function (input, onDone, options) {\r\n      this.options = Object.assign({}, {\r\n        // default options\r\n        binary: false,\r\n        trs: false,\r\n        onlyVisible: true,\r\n        truncateDrawRange: true,\r\n        embedImages: true,\r\n        maxTextureSize: Infinity,\r\n        animations: [],\r\n        includeCustomExtensions: false\r\n      }, options);\r\n\r\n      if (this.options.animations.length > 0) {\r\n        // Only TRS properties, and not matrices, may be targeted by animation.\r\n        this.options.trs = true;\r\n      }\r\n\r\n      this.processInput(input);\r\n      const writer = this;\r\n      Promise.all(this.pending).then(() => {\r\n        const buffers = writer.buffers;\r\n        const json = writer.json;\r\n        const options = writer.options;\r\n        const extensionsUsed = writer.extensionsUsed; // Merge buffers.\r\n\r\n        const blob = new Blob(buffers, {\r\n          type: 'application/octet-stream'\r\n        }); // Declare extensions.\r\n\r\n        const extensionsUsedList = Object.keys(extensionsUsed);\r\n        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\r\n\r\n        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\r\n\r\n        if (options.binary === true) {\r\n          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n          var reader = new window.FileReader();\r\n          reader.readAsArrayBuffer(blob);\r\n\r\n          reader.onloadend = () => {\r\n            // Binary chunk.\r\n            const binaryChunk = getPaddedArrayBuffer(reader.result);\r\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\r\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\r\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\r\n\r\n            const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\r\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\r\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\r\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\r\n\r\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\r\n            const headerView = new DataView(header);\r\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\r\n            headerView.setUint32(4, GLB_VERSION, true);\r\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\r\n            headerView.setUint32(8, totalByteLength, true);\r\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\r\n              type: 'application/octet-stream'\r\n            });\r\n            const glbReader = new window.FileReader();\r\n            glbReader.readAsArrayBuffer(glbBlob);\r\n\r\n            glbReader.onloadend = () => {\r\n              onDone(glbReader.result);\r\n            };\r\n          };\r\n        } else {\r\n          if (json.buffers && json.buffers.length > 0) {\r\n            var reader = new window.FileReader();\r\n            reader.readAsDataURL(blob);\r\n\r\n            reader.onloadend = () => {\r\n              const base64data = reader.result;\r\n              json.buffers[0].uri = base64data;\r\n              onDone(json);\r\n            };\r\n          } else {\r\n            onDone(json);\r\n          }\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Serializes a userData.\r\n     *\r\n     * @param {THREE.Object3D|THREE.Material} object\r\n     * @param {Object} objectDef\r\n     */\r\n    serializeUserData: function (object, objectDef) {\r\n      if (Object.keys(object.userData).length === 0) return;\r\n      const options = this.options;\r\n      const extensionsUsed = this.extensionsUsed;\r\n\r\n      try {\r\n        const json = JSON.parse(JSON.stringify(object.userData));\r\n\r\n        if (options.includeCustomExtensions && json.gltfExtensions) {\r\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\r\n\r\n          for (let extensionName in json.gltfExtensions) {\r\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\r\n            extensionsUsed[extensionName] = true;\r\n          }\r\n\r\n          delete json.gltfExtensions;\r\n        }\r\n\r\n        if (Object.keys(json).length > 0) objectDef.extras = json;\r\n      } catch (error) {\r\n        console.warn(`THREE.GLTFExporter: userData of '${object.name}' won't be serialized because of JSON.stringify error - ${error.message}`);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Assign and return a temporal unique id for an object\r\n     * especially which doesn't have .uuid\r\n     * @param  {Object} object\r\n     * @return {Integer}\r\n     */\r\n    getUID: function (object) {\r\n      if (!this.uids.has(object)) this.uids.set(object, this.uid++);\r\n      return this.uids.get(object);\r\n    },\r\n\r\n    /**\r\n     * Checks if normal attribute values are normalized.\r\n     *\r\n     * @param {BufferAttribute} normal\r\n     * @returns {Boolean}\r\n     */\r\n    isNormalizedNormalAttribute: function (normal) {\r\n      const cache = this.cache;\r\n      if (cache.attributesNormalized.has(normal)) return false;\r\n      const v = new Vector3();\r\n\r\n      for (let i = 0, il = normal.count; i < il; i++) {\r\n        // 0.0005 is from glTF-validator\r\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\r\n      }\r\n\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Creates normalized normal buffer attribute.\r\n     *\r\n     * @param {BufferAttribute} normal\r\n     * @returns {BufferAttribute}\r\n     *\r\n     */\r\n    createNormalizedNormalAttribute: function (normal) {\r\n      const cache = this.cache;\r\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\r\n      const attribute = normal.clone();\r\n      const v = new Vector3();\r\n\r\n      for (let i = 0, il = attribute.count; i < il; i++) {\r\n        v.fromBufferAttribute(attribute, i);\r\n\r\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\r\n          // if values can't be normalized set (1, 0, 0)\r\n          v.setX(1.0);\r\n        } else {\r\n          v.normalize();\r\n        }\r\n\r\n        attribute.setXYZ(i, v.x, v.y, v.z);\r\n      }\r\n\r\n      cache.attributesNormalized.set(normal, attribute);\r\n      return attribute;\r\n    },\r\n\r\n    /**\r\n     * Applies a texture transform, if present, to the map definition. Requires\r\n     * the KHR_texture_transform extension.\r\n     *\r\n     * @param {Object} mapDef\r\n     * @param {THREE.Texture} texture\r\n     */\r\n    applyTextureTransform: function (mapDef, texture) {\r\n      let didTransform = false;\r\n      const transformDef = {};\r\n\r\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\r\n        transformDef.offset = texture.offset.toArray();\r\n        didTransform = true;\r\n      }\r\n\r\n      if (texture.rotation !== 0) {\r\n        transformDef.rotation = texture.rotation;\r\n        didTransform = true;\r\n      }\r\n\r\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\r\n        transformDef.scale = texture.repeat.toArray();\r\n        didTransform = true;\r\n      }\r\n\r\n      if (didTransform) {\r\n        mapDef.extensions = mapDef.extensions || {};\r\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\r\n        this.extensionsUsed['KHR_texture_transform'] = true;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Process a buffer to append to the default one.\r\n     * @param  {ArrayBuffer} buffer\r\n     * @return {Integer}\r\n     */\r\n    processBuffer: function (buffer) {\r\n      const json = this.json;\r\n      const buffers = this.buffers;\r\n      if (!json.buffers) json.buffers = [{\r\n        byteLength: 0\r\n      }]; // All buffers are merged before export.\r\n\r\n      buffers.push(buffer);\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * Process and generate a BufferView\r\n     * @param  {BufferAttribute} attribute\r\n     * @param  {number} componentType\r\n     * @param  {number} start\r\n     * @param  {number} count\r\n     * @param  {number} target (Optional) Target usage of the BufferView\r\n     * @return {Object}\r\n     */\r\n    processBufferView: function (attribute, componentType, start, count, target) {\r\n      const json = this.json;\r\n      if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\r\n\r\n      let componentSize;\r\n\r\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\r\n        componentSize = 1;\r\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\r\n        componentSize = 2;\r\n      } else {\r\n        componentSize = 4;\r\n      }\r\n\r\n      const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\r\n      const dataView = new DataView(new ArrayBuffer(byteLength));\r\n      let offset = 0;\r\n\r\n      for (let i = start; i < start + count; i++) {\r\n        for (let a = 0; a < attribute.itemSize; a++) {\r\n          let value;\r\n\r\n          if (attribute.itemSize > 4) {\r\n            // no support for interleaved data for itemSize > 4\r\n            value = attribute.array[i * attribute.itemSize + a];\r\n          } else {\r\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\r\n          }\r\n\r\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\r\n            dataView.setFloat32(offset, value, true);\r\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\r\n            dataView.setUint32(offset, value, true);\r\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\r\n            dataView.setUint16(offset, value, true);\r\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\r\n            dataView.setUint8(offset, value);\r\n          }\r\n\r\n          offset += componentSize;\r\n        }\r\n      }\r\n\r\n      const bufferViewDef = {\r\n        buffer: this.processBuffer(dataView.buffer),\r\n        byteOffset: this.byteOffset,\r\n        byteLength\r\n      };\r\n      if (target !== undefined) bufferViewDef.target = target;\r\n\r\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\r\n        // Only define byteStride for vertex attributes.\r\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\r\n      }\r\n\r\n      this.byteOffset += byteLength;\r\n      json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\r\n\r\n      const output = {\r\n        id: json.bufferViews.length - 1,\r\n        byteLength: 0\r\n      };\r\n      return output;\r\n    },\r\n\r\n    /**\r\n     * Process and generate a BufferView from an image Blob.\r\n     * @param {Blob} blob\r\n     * @return {Promise<Integer>}\r\n     */\r\n    processBufferViewImage: function (blob) {\r\n      const writer = this;\r\n      const json = writer.json;\r\n      if (!json.bufferViews) json.bufferViews = [];\r\n      return new Promise(resolve => {\r\n        const reader = new window.FileReader();\r\n        reader.readAsArrayBuffer(blob);\r\n\r\n        reader.onloadend = () => {\r\n          const buffer = getPaddedArrayBuffer(reader.result);\r\n          const bufferViewDef = {\r\n            buffer: writer.processBuffer(buffer),\r\n            byteOffset: writer.byteOffset,\r\n            byteLength: buffer.byteLength\r\n          };\r\n          writer.byteOffset += buffer.byteLength;\r\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\r\n        };\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Process attribute to generate an accessor\r\n     * @param  {BufferAttribute} attribute Attribute to process\r\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\r\n     * @param  {Integer} start (Optional)\r\n     * @param  {Integer} count (Optional)\r\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\r\n     */\r\n    processAccessor: function (attribute, geometry, start, count) {\r\n      const options = this.options;\r\n      const json = this.json;\r\n      const types = {\r\n        1: 'SCALAR',\r\n        2: 'VEC2',\r\n        3: 'VEC3',\r\n        4: 'VEC4',\r\n        16: 'MAT4'\r\n      };\r\n      let componentType; // Detect the component type of the attribute array (float, uint or ushort)\r\n\r\n      if (attribute.array.constructor === Float32Array) {\r\n        componentType = WEBGL_CONSTANTS.FLOAT;\r\n      } else if (attribute.array.constructor === Uint32Array) {\r\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\r\n      } else if (attribute.array.constructor === Uint16Array) {\r\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\r\n      } else if (attribute.array.constructor === Uint8Array) {\r\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\r\n      } else {\r\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\r\n      }\r\n\r\n      if (start === undefined) start = 0;\r\n      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\r\n\r\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\r\n        const end = start + count;\r\n        const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\r\n        start = Math.max(start, geometry.drawRange.start);\r\n        count = Math.min(end, end2) - start;\r\n        if (count < 0) count = 0;\r\n      } // Skip creating an accessor if the attribute doesn't have data to export\r\n\r\n\r\n      if (count === 0) return null;\r\n      const minMax = getMinMax(attribute, start, count);\r\n      let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\r\n      // animation samplers, target must not be set.\r\n\r\n      if (geometry !== undefined) {\r\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\r\n      }\r\n\r\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\r\n      const accessorDef = {\r\n        bufferView: bufferView.id,\r\n        byteOffset: bufferView.byteOffset,\r\n        componentType,\r\n        count,\r\n        max: minMax.max,\r\n        min: minMax.min,\r\n        type: types[attribute.itemSize]\r\n      };\r\n      if (attribute.normalized === true) accessorDef.normalized = true;\r\n      if (!json.accessors) json.accessors = [];\r\n      return json.accessors.push(accessorDef) - 1;\r\n    },\r\n\r\n    /**\r\n     * Process image\r\n     * @param  {Image} image to process\r\n     * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\r\n     * @param  {Boolean} flipY before writing out the image\r\n     * @return {Integer}     Index of the processed texture in the \"images\" array\r\n     */\r\n    processImage: function (image, format, flipY) {\r\n      const writer = this;\r\n      const cache = writer.cache;\r\n      const json = writer.json;\r\n      const options = writer.options;\r\n      const pending = writer.pending;\r\n      if (!cache.images.has(image)) cache.images.set(image, {});\r\n      const cachedImages = cache.images.get(image);\r\n      const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\r\n      const key = `${mimeType}:flipY/${flipY.toString()}`;\r\n      if (cachedImages[key] !== undefined) return cachedImages[key];\r\n      if (!json.images) json.images = [];\r\n      const imageDef = {\r\n        mimeType\r\n      };\r\n\r\n      if (options.embedImages) {\r\n        const canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\r\n        canvas.width = Math.min(image.width, options.maxTextureSize);\r\n        canvas.height = Math.min(image.height, options.maxTextureSize);\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        if (flipY === true) {\r\n          ctx.translate(0, canvas.height);\r\n          ctx.scale(1, -1);\r\n        }\r\n\r\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\r\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\r\n        } else {\r\n          if (format !== RGBAFormat && format !== RGBFormat) {\r\n            console.error('GLTFExporter: Only RGB and RGBA formats are supported.');\r\n          }\r\n\r\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\r\n            console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\r\n          }\r\n\r\n          let data = image.data;\r\n\r\n          if (format === RGBFormat) {\r\n            data = new Uint8ClampedArray(image.height * image.width * 4);\r\n\r\n            for (let i = 0, j = 0; i < data.length; i += 4, j += 3) {\r\n              data[i + 0] = image.data[j + 0];\r\n              data[i + 1] = image.data[j + 1];\r\n              data[i + 2] = image.data[j + 2];\r\n              data[i + 3] = 255;\r\n            }\r\n          }\r\n\r\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\r\n        }\r\n\r\n        if (options.binary === true) {\r\n          pending.push(new Promise(resolve => {\r\n            canvas.toBlob(blob => {\r\n              writer.processBufferViewImage(blob).then(bufferViewIndex => {\r\n                imageDef.bufferView = bufferViewIndex;\r\n                resolve();\r\n              });\r\n            }, mimeType);\r\n          }));\r\n        } else {\r\n          imageDef.uri = canvas.toDataURL(mimeType);\r\n        }\r\n      } else {\r\n        imageDef.uri = image.src;\r\n      }\r\n\r\n      const index = json.images.push(imageDef) - 1;\r\n      cachedImages[key] = index;\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Process sampler\r\n     * @param  {Texture} map Texture to process\r\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\r\n     */\r\n    processSampler: function (map) {\r\n      const json = this.json;\r\n      if (!json.samplers) json.samplers = [];\r\n      const samplerDef = {\r\n        magFilter: THREE_TO_WEBGL[map.magFilter],\r\n        minFilter: THREE_TO_WEBGL[map.minFilter],\r\n        wrapS: THREE_TO_WEBGL[map.wrapS],\r\n        wrapT: THREE_TO_WEBGL[map.wrapT]\r\n      };\r\n      return json.samplers.push(samplerDef) - 1;\r\n    },\r\n\r\n    /**\r\n     * Process texture\r\n     * @param  {Texture} map Map to process\r\n     * @return {Integer} Index of the processed texture in the \"textures\" array\r\n     */\r\n    processTexture: function (map) {\r\n      const cache = this.cache;\r\n      const json = this.json;\r\n      if (cache.textures.has(map)) return cache.textures.get(map);\r\n      if (!json.textures) json.textures = [];\r\n      const textureDef = {\r\n        sampler: this.processSampler(map),\r\n        source: this.processImage(map.image, map.format, map.flipY)\r\n      };\r\n      if (map.name) textureDef.name = map.name;\r\n\r\n      this._invokeAll(ext => {\r\n        ext.writeTexture && ext.writeTexture(map, textureDef);\r\n      });\r\n\r\n      const index = json.textures.push(textureDef) - 1;\r\n      cache.textures.set(map, index);\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Process material\r\n     * @param  {THREE.Material} material Material to process\r\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\r\n     */\r\n    processMaterial: function (material) {\r\n      const cache = this.cache;\r\n      const json = this.json;\r\n      if (cache.materials.has(material)) return cache.materials.get(material);\r\n\r\n      if (material.isShaderMaterial) {\r\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\r\n        return null;\r\n      }\r\n\r\n      if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\r\n\r\n      const materialDef = {\r\n        pbrMetallicRoughness: {}\r\n      };\r\n\r\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\r\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\r\n      } // pbrMetallicRoughness.baseColorFactor\r\n\r\n\r\n      const color = material.color.toArray().concat([material.opacity]);\r\n\r\n      if (!equalArray(color, [1, 1, 1, 1])) {\r\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\r\n      }\r\n\r\n      if (material.isMeshStandardMaterial) {\r\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\r\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\r\n      } else {\r\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\r\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\r\n      } // pbrMetallicRoughness.metallicRoughnessTexture\r\n\r\n\r\n      if (material.metalnessMap || material.roughnessMap) {\r\n        if (material.metalnessMap === material.roughnessMap) {\r\n          const metalRoughMapDef = {\r\n            index: this.processTexture(material.metalnessMap)\r\n          };\r\n          this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\r\n          materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\r\n        } else {\r\n          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\r\n        }\r\n      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\r\n\r\n\r\n      if (material.map) {\r\n        const baseColorMapDef = {\r\n          index: this.processTexture(material.map)\r\n        };\r\n        this.applyTextureTransform(baseColorMapDef, material.map);\r\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\r\n      }\r\n\r\n      if (material.emissive) {\r\n        // emissiveFactor\r\n        const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\r\n\r\n        if (!equalArray(emissive, [0, 0, 0])) {\r\n          materialDef.emissiveFactor = emissive;\r\n        } // emissiveTexture\r\n\r\n\r\n        if (material.emissiveMap) {\r\n          const emissiveMapDef = {\r\n            index: this.processTexture(material.emissiveMap)\r\n          };\r\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\r\n          materialDef.emissiveTexture = emissiveMapDef;\r\n        }\r\n      } // normalTexture\r\n\r\n\r\n      if (material.normalMap) {\r\n        const normalMapDef = {\r\n          index: this.processTexture(material.normalMap)\r\n        };\r\n\r\n        if (material.normalScale && material.normalScale.x !== -1) {\r\n          if (material.normalScale.x !== material.normalScale.y) {\r\n            console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\r\n          }\r\n\r\n          normalMapDef.scale = material.normalScale.x;\r\n        }\r\n\r\n        this.applyTextureTransform(normalMapDef, material.normalMap);\r\n        materialDef.normalTexture = normalMapDef;\r\n      } // occlusionTexture\r\n\r\n\r\n      if (material.aoMap) {\r\n        const occlusionMapDef = {\r\n          index: this.processTexture(material.aoMap),\r\n          texCoord: 1\r\n        };\r\n\r\n        if (material.aoMapIntensity !== 1.0) {\r\n          occlusionMapDef.strength = material.aoMapIntensity;\r\n        }\r\n\r\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\r\n        materialDef.occlusionTexture = occlusionMapDef;\r\n      } // alphaMode\r\n\r\n\r\n      if (material.transparent) {\r\n        materialDef.alphaMode = 'BLEND';\r\n      } else {\r\n        if (material.alphaTest > 0.0) {\r\n          materialDef.alphaMode = 'MASK';\r\n          materialDef.alphaCutoff = material.alphaTest;\r\n        }\r\n      } // doubleSided\r\n\r\n\r\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\r\n      if (material.name !== '') materialDef.name = material.name;\r\n      this.serializeUserData(material, materialDef);\r\n\r\n      this._invokeAll(ext => {\r\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\r\n      });\r\n\r\n      const index = json.materials.push(materialDef) - 1;\r\n      cache.materials.set(material, index);\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Process mesh\r\n     * @param  {THREE.Mesh} mesh Mesh to process\r\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\r\n     */\r\n    processMesh: function (mesh) {\r\n      const cache = this.cache;\r\n      const json = this.json;\r\n      const meshCacheKeyParts = [mesh.geometry.uuid];\r\n\r\n      if (Array.isArray(mesh.material)) {\r\n        for (let i = 0, l = mesh.material.length; i < l; i++) {\r\n          meshCacheKeyParts.push(mesh.material[i].uuid);\r\n        }\r\n      } else {\r\n        meshCacheKeyParts.push(mesh.material.uuid);\r\n      }\r\n\r\n      const meshCacheKey = meshCacheKeyParts.join(':');\r\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\r\n      const geometry = mesh.geometry;\r\n      let mode; // Use the correct mode\r\n\r\n      if (mesh.isLineSegments) {\r\n        mode = WEBGL_CONSTANTS.LINES;\r\n      } else if (mesh.isLineLoop) {\r\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\r\n      } else if (mesh.isLine) {\r\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\r\n      } else if (mesh.isPoints) {\r\n        mode = WEBGL_CONSTANTS.POINTS;\r\n      } else {\r\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\r\n      }\r\n\r\n      if (geometry.isBufferGeometry !== true) {\r\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\r\n      }\r\n\r\n      const meshDef = {};\r\n      const attributes = {};\r\n      const primitives = [];\r\n      const targets = []; // Conversion between attributes names in threejs and gltf spec\r\n\r\n      const nameConversion = {\r\n        uv: 'TEXCOORD_0',\r\n        uv2: 'TEXCOORD_1',\r\n        color: 'COLOR_0',\r\n        skinWeight: 'WEIGHTS_0',\r\n        skinIndex: 'JOINTS_0'\r\n      };\r\n      const originalNormal = geometry.getAttribute('normal');\r\n\r\n      if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\r\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\r\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\r\n      } // @QUESTION Detect if .vertexColors = true?\r\n      // For every attribute create an accessor\r\n\r\n\r\n      let modifiedAttribute = null;\r\n\r\n      for (let attributeName in geometry.attributes) {\r\n        // Ignore morph target attributes, which are exported later.\r\n        if (attributeName.substr(0, 5) === 'morph') continue;\r\n        var attribute = geometry.attributes[attributeName];\r\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\r\n        // listed in the spec; non-spec attributes are considered custom.\r\n\r\n        const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\r\n        if (!validVertexAttributes.test(attributeName)) attributeName = `_${attributeName}`;\r\n\r\n        if (cache.attributes.has(this.getUID(attribute))) {\r\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\r\n          continue;\r\n        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\r\n\r\n\r\n        modifiedAttribute = null;\r\n        const array = attribute.array;\r\n\r\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\r\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\r\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\r\n        }\r\n\r\n        const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\r\n\r\n        if (accessor !== null) {\r\n          attributes[attributeName] = accessor;\r\n          cache.attributes.set(this.getUID(attribute), accessor);\r\n        }\r\n      }\r\n\r\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\r\n\r\n      if (Object.keys(attributes).length === 0) return null; // Morph targets\r\n\r\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\r\n        const weights = [];\r\n        const targetNames = [];\r\n        const reverseDictionary = {};\r\n\r\n        if (mesh.morphTargetDictionary !== undefined) {\r\n          for (let key in mesh.morphTargetDictionary) {\r\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\r\n          }\r\n        }\r\n\r\n        for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\r\n          const target = {};\r\n          let warned = false;\r\n\r\n          for (let attributeName in geometry.morphAttributes) {\r\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\r\n            // Three.js doesn't support TANGENT yet.\r\n            if (attributeName !== 'position' && attributeName !== 'normal') {\r\n              if (!warned) {\r\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\r\n                warned = true;\r\n              }\r\n\r\n              continue;\r\n            }\r\n\r\n            var attribute = geometry.morphAttributes[attributeName][i];\r\n            const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\r\n            //\r\n            // glTF 2.0 Specification:\r\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\r\n\r\n            const baseAttribute = geometry.attributes[attributeName];\r\n\r\n            if (cache.attributes.has(this.getUID(attribute))) {\r\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\r\n              continue;\r\n            } // Clones attribute not to override\r\n\r\n\r\n            const relativeAttribute = attribute.clone();\r\n\r\n            if (!geometry.morphTargetsRelative) {\r\n              for (let j = 0, jl = attribute.count; j < jl; j++) {\r\n                relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\r\n              }\r\n            }\r\n\r\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\r\n            cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\r\n          }\r\n\r\n          targets.push(target);\r\n          weights.push(mesh.morphTargetInfluences[i]);\r\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\r\n        }\r\n\r\n        meshDef.weights = weights;\r\n\r\n        if (targetNames.length > 0) {\r\n          meshDef.extras = {};\r\n          meshDef.extras.targetNames = targetNames;\r\n        }\r\n      }\r\n\r\n      const isMultiMaterial = Array.isArray(mesh.material);\r\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\r\n      const materials = isMultiMaterial ? mesh.material : [mesh.material];\r\n      const groups = isMultiMaterial ? geometry.groups : [{\r\n        materialIndex: 0,\r\n        start: undefined,\r\n        count: undefined\r\n      }];\r\n\r\n      for (let i = 0, il = groups.length; i < il; i++) {\r\n        const primitive = {\r\n          mode,\r\n          attributes\r\n        };\r\n        this.serializeUserData(geometry, primitive);\r\n        if (targets.length > 0) primitive.targets = targets;\r\n\r\n        if (geometry.index !== null) {\r\n          let cacheKey = this.getUID(geometry.index);\r\n\r\n          if (groups[i].start !== undefined || groups[i].count !== undefined) {\r\n            cacheKey += `:${groups[i].start}:${groups[i].count}`;\r\n          }\r\n\r\n          if (cache.attributes.has(cacheKey)) {\r\n            primitive.indices = cache.attributes.get(cacheKey);\r\n          } else {\r\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\r\n            cache.attributes.set(cacheKey, primitive.indices);\r\n          }\r\n\r\n          if (primitive.indices === null) delete primitive.indices;\r\n        }\r\n\r\n        const material = this.processMaterial(materials[groups[i].materialIndex]);\r\n        if (material !== null) primitive.material = material;\r\n        primitives.push(primitive);\r\n      }\r\n\r\n      meshDef.primitives = primitives;\r\n      if (!json.meshes) json.meshes = [];\r\n\r\n      this._invokeAll(ext => {\r\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\r\n      });\r\n\r\n      const index = json.meshes.push(meshDef) - 1;\r\n      cache.meshes.set(meshCacheKey, index);\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Process camera\r\n     * @param  {THREE.Camera} camera Camera to process\r\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\r\n     */\r\n    processCamera: function (camera) {\r\n      const json = this.json;\r\n      if (!json.cameras) json.cameras = [];\r\n      const isOrtho = camera.isOrthographicCamera;\r\n      const cameraDef = {\r\n        type: isOrtho ? 'orthographic' : 'perspective'\r\n      };\r\n\r\n      if (isOrtho) {\r\n        cameraDef.orthographic = {\r\n          xmag: camera.right * 2,\r\n          ymag: camera.top * 2,\r\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\r\n          znear: camera.near < 0 ? 0 : camera.near\r\n        };\r\n      } else {\r\n        cameraDef.perspective = {\r\n          aspectRatio: camera.aspect,\r\n          yfov: MathUtils.degToRad(camera.fov),\r\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\r\n          znear: camera.near < 0 ? 0 : camera.near\r\n        };\r\n      } // Question: Is saving \"type\" as name intentional?\r\n\r\n\r\n      if (camera.name !== '') cameraDef.name = camera.type;\r\n      return json.cameras.push(cameraDef) - 1;\r\n    },\r\n\r\n    /**\r\n     * Creates glTF animation entry from AnimationClip object.\r\n     *\r\n     * Status:\r\n     * - Only properties listed in PATH_PROPERTIES may be animated.\r\n     *\r\n     * @param {THREE.AnimationClip} clip\r\n     * @param {THREE.Object3D} root\r\n     * @return {number|null}\r\n     */\r\n    processAnimation: function (clip, root) {\r\n      const json = this.json;\r\n      const nodeMap = this.nodeMap;\r\n      if (!json.animations) json.animations = [];\r\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\r\n      const tracks = clip.tracks;\r\n      const channels = [];\r\n      const samplers = [];\r\n\r\n      for (let i = 0; i < tracks.length; ++i) {\r\n        const track = tracks[i];\r\n        const trackBinding = PropertyBinding.parseTrackName(track.name);\r\n        let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\r\n        const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\r\n\r\n        if (trackBinding.objectName === 'bones') {\r\n          if (trackNode.isSkinnedMesh === true) {\r\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\r\n          } else {\r\n            trackNode = undefined;\r\n          }\r\n        }\r\n\r\n        if (!trackNode || !trackProperty) {\r\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\r\n          return null;\r\n        }\r\n\r\n        const inputItemSize = 1;\r\n        let outputItemSize = track.values.length / track.times.length;\r\n\r\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\r\n          outputItemSize /= trackNode.morphTargetInfluences.length;\r\n        }\r\n\r\n        let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\r\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\r\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\r\n        // valid value from .getInterpolation().\r\n\r\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\r\n          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\r\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\r\n          // but needs to be stored as VEC3 so dividing by 3 here.\r\n\r\n          outputItemSize /= 3;\r\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\r\n          interpolation = 'STEP';\r\n        } else {\r\n          interpolation = 'LINEAR';\r\n        }\r\n\r\n        samplers.push({\r\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\r\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\r\n          interpolation\r\n        });\r\n        channels.push({\r\n          sampler: samplers.length - 1,\r\n          target: {\r\n            node: nodeMap.get(trackNode),\r\n            path: trackProperty\r\n          }\r\n        });\r\n      }\r\n\r\n      json.animations.push({\r\n        name: clip.name || `clip_${json.animations.length}`,\r\n        samplers,\r\n        channels\r\n      });\r\n      return json.animations.length - 1;\r\n    },\r\n\r\n    /**\r\n     * @param {THREE.Object3D} object\r\n     * @return {number|null}\r\n     */\r\n    processSkin: function (object) {\r\n      const json = this.json;\r\n      const nodeMap = this.nodeMap;\r\n      const node = json.nodes[nodeMap.get(object)];\r\n      const skeleton = object.skeleton;\r\n      if (skeleton === undefined) return null;\r\n      const rootJoint = object.skeleton.bones[0];\r\n      if (rootJoint === undefined) return null;\r\n      const joints = [];\r\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\r\n      const temporaryBoneInverse = new Matrix4();\r\n\r\n      for (let i = 0; i < skeleton.bones.length; ++i) {\r\n        joints.push(nodeMap.get(skeleton.bones[i]));\r\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\r\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\r\n      }\r\n\r\n      if (json.skins === undefined) json.skins = [];\r\n      json.skins.push({\r\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\r\n        joints,\r\n        skeleton: nodeMap.get(rootJoint)\r\n      });\r\n      const skinIndex = node.skin = json.skins.length - 1;\r\n      return skinIndex;\r\n    },\r\n\r\n    /**\r\n     * Process Object3D node\r\n     * @param  {THREE.Object3D} node Object3D to processNode\r\n     * @return {Integer} Index of the node in the nodes list\r\n     */\r\n    processNode: function (object) {\r\n      const json = this.json;\r\n      const options = this.options;\r\n      const nodeMap = this.nodeMap;\r\n      if (!json.nodes) json.nodes = [];\r\n      const nodeDef = {};\r\n\r\n      if (options.trs) {\r\n        const rotation = object.quaternion.toArray();\r\n        const position = object.position.toArray();\r\n        const scale = object.scale.toArray();\r\n\r\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\r\n          nodeDef.rotation = rotation;\r\n        }\r\n\r\n        if (!equalArray(position, [0, 0, 0])) {\r\n          nodeDef.translation = position;\r\n        }\r\n\r\n        if (!equalArray(scale, [1, 1, 1])) {\r\n          nodeDef.scale = scale;\r\n        }\r\n      } else {\r\n        if (object.matrixAutoUpdate) {\r\n          object.updateMatrix();\r\n        }\r\n\r\n        if (isIdentityMatrix(object.matrix) === false) {\r\n          nodeDef.matrix = object.matrix.elements;\r\n        }\r\n      } // We don't export empty strings name because it represents no-name in Three.js.\r\n\r\n\r\n      if (object.name !== '') nodeDef.name = String(object.name);\r\n      this.serializeUserData(object, nodeDef);\r\n\r\n      if (object.isMesh || object.isLine || object.isPoints) {\r\n        const meshIndex = this.processMesh(object);\r\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\r\n      } else if (object.isCamera) {\r\n        nodeDef.camera = this.processCamera(object);\r\n      }\r\n\r\n      if (object.isSkinnedMesh) this.skins.push(object);\r\n\r\n      if (object.children.length > 0) {\r\n        const children = [];\r\n\r\n        for (let i = 0, l = object.children.length; i < l; i++) {\r\n          const child = object.children[i];\r\n\r\n          if (child.visible || options.onlyVisible === false) {\r\n            var nodeIndex = this.processNode(child);\r\n            if (nodeIndex !== null) children.push(nodeIndex);\r\n          }\r\n        }\r\n\r\n        if (children.length > 0) nodeDef.children = children;\r\n      }\r\n\r\n      this._invokeAll(ext => {\r\n        ext.writeNode && ext.writeNode(object, nodeDef);\r\n      });\r\n\r\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\r\n      nodeMap.set(object, nodeIndex);\r\n      return nodeIndex;\r\n    },\r\n\r\n    /**\r\n     * Process Scene\r\n     * @param  {Scene} node Scene to process\r\n     */\r\n    processScene: function (scene) {\r\n      const json = this.json;\r\n      const options = this.options;\r\n\r\n      if (!json.scenes) {\r\n        json.scenes = [];\r\n        json.scene = 0;\r\n      }\r\n\r\n      const sceneDef = {};\r\n      if (scene.name !== '') sceneDef.name = scene.name;\r\n      json.scenes.push(sceneDef);\r\n      const nodes = [];\r\n\r\n      for (let i = 0, l = scene.children.length; i < l; i++) {\r\n        const child = scene.children[i];\r\n\r\n        if (child.visible || options.onlyVisible === false) {\r\n          const nodeIndex = this.processNode(child);\r\n          if (nodeIndex !== null) nodes.push(nodeIndex);\r\n        }\r\n      }\r\n\r\n      if (nodes.length > 0) sceneDef.nodes = nodes;\r\n      this.serializeUserData(scene, sceneDef);\r\n    },\r\n\r\n    /**\r\n     * Creates a Scene to hold a list of objects and parse it\r\n     * @param  {Array} objects List of objects to process\r\n     */\r\n    processObjects: function (objects) {\r\n      const scene = new Scene();\r\n      scene.name = 'AuxScene';\r\n\r\n      for (let i = 0; i < objects.length; i++) {\r\n        // We push directly to children instead of calling `add` to prevent\r\n        // modify the .parent and break its original scene and hierarchy\r\n        scene.children.push(objects[i]);\r\n      }\r\n\r\n      this.processScene(scene);\r\n    },\r\n\r\n    /**\r\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\r\n     */\r\n    processInput: function (input) {\r\n      const options = this.options;\r\n      input = input instanceof Array ? input : [input];\r\n\r\n      this._invokeAll(ext => {\r\n        ext.beforeParse && ext.beforeParse(input);\r\n      });\r\n\r\n      const objectsWithoutScene = [];\r\n\r\n      for (let i = 0; i < input.length; i++) {\r\n        if (input[i] instanceof Scene) {\r\n          this.processScene(input[i]);\r\n        } else {\r\n          objectsWithoutScene.push(input[i]);\r\n        }\r\n      }\r\n\r\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\r\n\r\n      for (let i = 0; i < this.skins.length; ++i) {\r\n        this.processSkin(this.skins[i]);\r\n      }\r\n\r\n      for (let i = 0; i < options.animations.length; ++i) {\r\n        this.processAnimation(options.animations[i], input[0]);\r\n      }\r\n\r\n      this._invokeAll(ext => {\r\n        ext.afterParse && ext.afterParse(input);\r\n      });\r\n    },\r\n    _invokeAll: function (func) {\r\n      for (let i = 0, il = this.plugins.length; i < il; i++) {\r\n        func(this.plugins[i]);\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Punctual Lights Extension\r\n   *\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n   */\r\n\r\n  function GLTFLightExtension(writer) {\r\n    this.writer = writer;\r\n    this.name = 'KHR_lights_punctual';\r\n  }\r\n\r\n  GLTFLightExtension.prototype = {\r\n    constructor: GLTFLightExtension,\r\n    writeNode: function (light, nodeDef) {\r\n      if (!light.isLight) return;\r\n\r\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\r\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\r\n        return;\r\n      }\r\n\r\n      const writer = this.writer;\r\n      const json = writer.json;\r\n      const extensionsUsed = writer.extensionsUsed;\r\n      const lightDef = {};\r\n      if (light.name) lightDef.name = light.name;\r\n      lightDef.color = light.color.toArray();\r\n      lightDef.intensity = light.intensity;\r\n\r\n      if (light.isDirectionalLight) {\r\n        lightDef.type = 'directional';\r\n      } else if (light.isPointLight) {\r\n        lightDef.type = 'point';\r\n        if (light.distance > 0) lightDef.range = light.distance;\r\n      } else if (light.isSpotLight) {\r\n        lightDef.type = 'spot';\r\n        if (light.distance > 0) lightDef.range = light.distance;\r\n        lightDef.spot = {};\r\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\r\n        lightDef.spot.outerConeAngle = light.angle;\r\n      }\r\n\r\n      if (light.decay !== undefined && light.decay !== 2) {\r\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\r\n      }\r\n\r\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\r\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\r\n      }\r\n\r\n      if (!extensionsUsed[this.name]) {\r\n        json.extensions = json.extensions || {};\r\n        json.extensions[this.name] = {\r\n          lights: []\r\n        };\r\n        extensionsUsed[this.name] = true;\r\n      }\r\n\r\n      const lights = json.extensions[this.name].lights;\r\n      lights.push(lightDef);\r\n      nodeDef.extensions = nodeDef.extensions || {};\r\n      nodeDef.extensions[this.name] = {\r\n        light: lights.length - 1\r\n      };\r\n    }\r\n  };\r\n  /**\r\n   * Unlit Materials Extension\r\n   *\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n   */\r\n\r\n  function GLTFMaterialsUnlitExtension(writer) {\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_unlit';\r\n  }\r\n\r\n  GLTFMaterialsUnlitExtension.prototype = {\r\n    constructor: GLTFMaterialsUnlitExtension,\r\n    writeMaterial: function (material, materialDef) {\r\n      if (!material.isMeshBasicMaterial) return;\r\n      const writer = this.writer;\r\n      const extensionsUsed = writer.extensionsUsed;\r\n      materialDef.extensions = materialDef.extensions || {};\r\n      materialDef.extensions[this.name] = {};\r\n      extensionsUsed[this.name] = true;\r\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\r\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\r\n    }\r\n  };\r\n  /**\r\n   * Specular-Glossiness Extension\r\n   *\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n   */\r\n\r\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\r\n  }\r\n\r\n  GLTFMaterialsPBRSpecularGlossiness.prototype = {\r\n    constructor: GLTFMaterialsPBRSpecularGlossiness,\r\n    writeMaterial: function (material, materialDef) {\r\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\r\n      const writer = this.writer;\r\n      const extensionsUsed = writer.extensionsUsed;\r\n      const extensionDef = {};\r\n\r\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\r\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\r\n      }\r\n\r\n      const specularFactor = [1, 1, 1];\r\n      material.specular.toArray(specularFactor, 0);\r\n      extensionDef.specularFactor = specularFactor;\r\n      extensionDef.glossinessFactor = material.glossiness;\r\n\r\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\r\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\r\n      }\r\n\r\n      if (material.specularMap) {\r\n        const specularMapDef = {\r\n          index: writer.processTexture(material.specularMap)\r\n        };\r\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\r\n        extensionDef.specularGlossinessTexture = specularMapDef;\r\n      }\r\n\r\n      materialDef.extensions = materialDef.extensions || {};\r\n      materialDef.extensions[this.name] = extensionDef;\r\n      extensionsUsed[this.name] = true;\r\n    }\r\n  };\r\n  /**\r\n   * Static utility functions\r\n   */\r\n\r\n  GLTFExporter.Utils = {\r\n    insertKeyframe: function (track, time) {\r\n      const tolerance = 0.001; // 1ms\r\n\r\n      const valueSize = track.getValueSize();\r\n      const times = new track.TimeBufferType(track.times.length + 1);\r\n      const values = new track.ValueBufferType(track.values.length + valueSize);\r\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\r\n      let index;\r\n\r\n      if (track.times.length === 0) {\r\n        times[0] = time;\r\n\r\n        for (let i = 0; i < valueSize; i++) {\r\n          values[i] = 0;\r\n        }\r\n\r\n        index = 0;\r\n      } else if (time < track.times[0]) {\r\n        if (Math.abs(track.times[0] - time) < tolerance) return 0;\r\n        times[0] = time;\r\n        times.set(track.times, 1);\r\n        values.set(interpolant.evaluate(time), 0);\r\n        values.set(track.values, valueSize);\r\n        index = 0;\r\n      } else if (time > track.times[track.times.length - 1]) {\r\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\r\n          return track.times.length - 1;\r\n        }\r\n\r\n        times[times.length - 1] = time;\r\n        times.set(track.times, 0);\r\n        values.set(track.values, 0);\r\n        values.set(interpolant.evaluate(time), track.values.length);\r\n        index = times.length - 1;\r\n      } else {\r\n        for (let i = 0; i < track.times.length; i++) {\r\n          if (Math.abs(track.times[i] - time) < tolerance) return i;\r\n\r\n          if (track.times[i] < time && track.times[i + 1] > time) {\r\n            times.set(track.times.slice(0, i + 1), 0);\r\n            times[i + 1] = time;\r\n            times.set(track.times.slice(i + 1), i + 2);\r\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0);\r\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize);\r\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\r\n            index = i + 1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      track.times = times;\r\n      track.values = values;\r\n      return index;\r\n    },\r\n    mergeMorphTargetTracks: function (clip, root) {\r\n      const tracks = [];\r\n      const mergedTracks = {};\r\n      const sourceTracks = clip.tracks;\r\n\r\n      for (let i = 0; i < sourceTracks.length; ++i) {\r\n        let sourceTrack = sourceTracks[i];\r\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\r\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\r\n\r\n        if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\r\n          // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\r\n          tracks.push(sourceTrack);\r\n          continue;\r\n        }\r\n\r\n        if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\r\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\r\n            // This should never happen, because glTF morph target animations\r\n            // affect all targets already.\r\n            throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\r\n          }\r\n\r\n          console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\r\n          sourceTrack = sourceTrack.clone();\r\n          sourceTrack.setInterpolation(InterpolateLinear);\r\n        }\r\n\r\n        const targetCount = sourceTrackNode.morphTargetInfluences.length;\r\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\r\n\r\n        if (targetIndex === undefined) {\r\n          throw new Error(`THREE.GLTFExporter: Morph target name not found: ${sourceTrackBinding.propertyIndex}`);\r\n        }\r\n\r\n        let mergedTrack; // If this is the first time we've seen this object, create a new\r\n        // track to store merged keyframe data for each morph target.\r\n\r\n        if (mergedTracks[sourceTrackNode.uuid] === undefined) {\r\n          mergedTrack = sourceTrack.clone();\r\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\r\n\r\n          for (let j = 0; j < mergedTrack.times.length; j++) {\r\n            values[j * targetCount + targetIndex] = mergedTrack.values[j];\r\n          } // We need to take into consideration the intended target node\r\n          // of our original un-merged morphTarget animation.\r\n\r\n\r\n          mergedTrack.name = `${sourceTrackBinding.nodeName || ''}.morphTargetInfluences`;\r\n          mergedTrack.values = values;\r\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack;\r\n          tracks.push(mergedTrack);\r\n          continue;\r\n        }\r\n\r\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\r\n        mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\r\n        // interpolated) value from the source track.\r\n\r\n        for (let j = 0; j < mergedTrack.times.length; j++) {\r\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\r\n        } // For every existing keyframe of the source track, write a (possibly\r\n        // new) keyframe to the merged track. Values from the previous loop may\r\n        // be written again, but keyframes are de-duplicated.\r\n\r\n\r\n        for (let j = 0; j < sourceTrack.times.length; j++) {\r\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\r\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\r\n        }\r\n      }\r\n\r\n      clip.tracks = tracks;\r\n      return clip;\r\n    }\r\n  };\r\n  return GLTFExporter;\r\n})();\r\n\r\nexport { GLTFExporter };\r\n"]},"metadata":{},"sourceType":"module"}