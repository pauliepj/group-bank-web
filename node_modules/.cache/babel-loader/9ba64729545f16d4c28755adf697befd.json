{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addNoneTerminalToCst = exports.addTerminalToCst = exports.setNodeLocationFull = exports.setNodeLocationOnlyOffset = void 0;\n/**\r\n * This nodeLocation tracking is not efficient and should only be used\r\n * when error recovery is enabled or the Token Vector contains virtual Tokens\r\n * (e.g, Python Indent/Outdent)\r\n * As it executes the calculation for every single terminal/nonTerminal\r\n * and does not rely on the fact the token vector is **sorted**\r\n */\n\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  } // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n      currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n\nexports.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;\n/**\r\n * This nodeLocation tracking is not efficient and should only be used\r\n * when error recovery is enabled or the Token Vector contains virtual Tokens\r\n * (e.g, Python Indent/Outdent)\r\n * As it executes the calculation for every single terminal/nonTerminal\r\n * and does not rely on the fact the token vector is **sorted**\r\n */\n\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  } // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n      currNodeLocation.endOffset = newLocationInfo.endOffset;\n      currNodeLocation.endColumn = newLocationInfo.endColumn;\n      currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\n\nexports.setNodeLocationFull = setNodeLocationFull;\n\nfunction addTerminalToCst(node, token, tokenTypeName) {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\n\nexports.addTerminalToCst = addTerminalToCst;\n\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\n\nexports.addNoneTerminalToCst = addNoneTerminalToCst;","map":{"version":3,"sources":["../../../../src/parse/cst/cst.ts"],"names":[],"mappings":";;;;;;AAEA;;;;;;AAMG;;AACH,SAAgB,yBAAhB,CACE,gBADF,EAEE,eAFF,EAEyB;AAEvB;AACA,MAAI,KAAK,CAAC,gBAAgB,CAAC,WAAlB,CAAL,KAAwC,IAA5C,EAAkD;AAChD;AACA;AACA;AACA,IAAA,gBAAgB,CAAC,WAAjB,GAA+B,eAAe,CAAC,WAA/C;AACA,IAAA,gBAAgB,CAAC,SAAjB,GAA6B,eAAe,CAAC,SAA7C;AACD,GAND,CAOA;AACA;AACA;AACA;AAVA,OAWK,IAAI,gBAAgB,CAAC,SAAjB,GAA6B,eAAe,CAAC,SAA7C,KAA2D,IAA/D,EAAqE;AACxE,MAAA,gBAAgB,CAAC,SAAjB,GAA6B,eAAe,CAAC,SAA7C;AACD;AACF;;AAnBD,OAAA,CAAA,yBAAA,GAAA,yBAAA;AAqBA;;;;;;AAMG;;AACH,SAAgB,mBAAhB,CACE,gBADF,EAEE,eAFF,EAEkC;AAEhC;AACA,MAAI,KAAK,CAAC,gBAAgB,CAAC,WAAlB,CAAL,KAAwC,IAA5C,EAAkD;AAChD;AACA;AACA;AACA,IAAA,gBAAgB,CAAC,WAAjB,GAA+B,eAAe,CAAC,WAA/C;AACA,IAAA,gBAAgB,CAAC,WAAjB,GAA+B,eAAe,CAAC,WAA/C;AACA,IAAA,gBAAgB,CAAC,SAAjB,GAA6B,eAAe,CAAC,SAA7C;AACA,IAAA,gBAAgB,CAAC,SAAjB,GAA6B,eAAe,CAAC,SAA7C;AACA,IAAA,gBAAgB,CAAC,SAAjB,GAA6B,eAAe,CAAC,SAA7C;AACA,IAAA,gBAAgB,CAAC,OAAjB,GAA2B,eAAe,CAAC,OAA3C;AACD,GAVD,CAWA;AACA;AACA;AACA;AAdA,OAeK,IAAI,gBAAgB,CAAC,SAAjB,GAA6B,eAAe,CAAC,SAA7C,KAA2D,IAA/D,EAAqE;AACxE,MAAA,gBAAgB,CAAC,SAAjB,GAA6B,eAAe,CAAC,SAA7C;AACA,MAAA,gBAAgB,CAAC,SAAjB,GAA6B,eAAe,CAAC,SAA7C;AACA,MAAA,gBAAgB,CAAC,OAAjB,GAA2B,eAAe,CAAC,OAA3C;AACD;AACF;;AAzBD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AA2BA,SAAgB,gBAAhB,CACE,IADF,EAEE,KAFF,EAGE,aAHF,EAGuB;AAErB,MAAI,IAAI,CAAC,QAAL,CAAc,aAAd,MAAiC,SAArC,EAAgD;AAC9C,IAAA,IAAI,CAAC,QAAL,CAAc,aAAd,IAA+B,CAAC,KAAD,CAA/B;AACD,GAFD,MAEO;AACL,IAAA,IAAI,CAAC,QAAL,CAAc,aAAd,EAA6B,IAA7B,CAAkC,KAAlC;AACD;AACF;;AAVD,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAYA,SAAgB,oBAAhB,CACE,IADF,EAEE,QAFF,EAGE,UAHF,EAGiB;AAEf,MAAI,IAAI,CAAC,QAAL,CAAc,QAAd,MAA4B,SAAhC,EAA2C;AACzC,IAAA,IAAI,CAAC,QAAL,CAAc,QAAd,IAA0B,CAAC,UAAD,CAA1B;AACD,GAFD,MAEO;AACL,IAAA,IAAI,CAAC,QAAL,CAAc,QAAd,EAAwB,IAAxB,CAA6B,UAA7B;AACD;AACF;;AAVD,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.addNoneTerminalToCst = exports.addTerminalToCst = exports.setNodeLocationFull = exports.setNodeLocationOnlyOffset = void 0;\r\n/**\r\n * This nodeLocation tracking is not efficient and should only be used\r\n * when error recovery is enabled or the Token Vector contains virtual Tokens\r\n * (e.g, Python Indent/Outdent)\r\n * As it executes the calculation for every single terminal/nonTerminal\r\n * and does not rely on the fact the token vector is **sorted**\r\n */\r\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\r\n    // First (valid) update for this cst node\r\n    if (isNaN(currNodeLocation.startOffset) === true) {\r\n        // assumption1: Token location information is either NaN or a valid number\r\n        // assumption2: Token location information is fully valid if it exist\r\n        // (both start/end offsets exist and are numbers).\r\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\r\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\r\n    }\r\n    // Once the startOffset has been updated with a valid number it should never receive\r\n    // any farther updates as the Token vector is sorted.\r\n    // We still have to check this this condition for every new possible location info\r\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\r\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\r\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\r\n    }\r\n}\r\nexports.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;\r\n/**\r\n * This nodeLocation tracking is not efficient and should only be used\r\n * when error recovery is enabled or the Token Vector contains virtual Tokens\r\n * (e.g, Python Indent/Outdent)\r\n * As it executes the calculation for every single terminal/nonTerminal\r\n * and does not rely on the fact the token vector is **sorted**\r\n */\r\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\r\n    // First (valid) update for this cst node\r\n    if (isNaN(currNodeLocation.startOffset) === true) {\r\n        // assumption1: Token location information is either NaN or a valid number\r\n        // assumption2: Token location information is fully valid if it exist\r\n        // (all start/end props exist and are numbers).\r\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\r\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\r\n        currNodeLocation.startLine = newLocationInfo.startLine;\r\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\r\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\r\n        currNodeLocation.endLine = newLocationInfo.endLine;\r\n    }\r\n    // Once the start props has been updated with a valid number it should never receive\r\n    // any farther updates as the Token vector is sorted.\r\n    // We still have to check this this condition for every new possible location info\r\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\r\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\r\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\r\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\r\n        currNodeLocation.endLine = newLocationInfo.endLine;\r\n    }\r\n}\r\nexports.setNodeLocationFull = setNodeLocationFull;\r\nfunction addTerminalToCst(node, token, tokenTypeName) {\r\n    if (node.children[tokenTypeName] === undefined) {\r\n        node.children[tokenTypeName] = [token];\r\n    }\r\n    else {\r\n        node.children[tokenTypeName].push(token);\r\n    }\r\n}\r\nexports.addTerminalToCst = addTerminalToCst;\r\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\r\n    if (node.children[ruleName] === undefined) {\r\n        node.children[ruleName] = [ruleResult];\r\n    }\r\n    else {\r\n        node.children[ruleName].push(ruleResult);\r\n    }\r\n}\r\nexports.addNoneTerminalToCst = addNoneTerminalToCst;\r\n//# sourceMappingURL=cst.js.map"]},"metadata":{},"sourceType":"script"}