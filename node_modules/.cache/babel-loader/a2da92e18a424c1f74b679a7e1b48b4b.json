{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TreeBuilder = void 0;\n\nvar cst_1 = require(\"../../cst/cst\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar cst_visitor_1 = require(\"../../cst/cst_visitor\");\n\nvar parser_1 = require(\"../parser\");\n/**\r\n * This trait is responsible for the CST building logic.\r\n */\n\n\nvar TreeBuilder =\n/** @class */\nfunction () {\n  function TreeBuilder() {}\n\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.CST_STACK = []; // outputCst is no longer exposed/defined in the pubic API\n\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = utils_1.has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = utils_1.NOOP;\n      this.cstFinallyStateUpdate = utils_1.NOOP;\n      this.cstPostTerminal = utils_1.NOOP;\n      this.cstPostNonTerminal = utils_1.NOOP;\n      this.cstPostRule = utils_1.NOOP;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\n          this.cstPostRule = utils_1.NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = utils_1.NOOP;\n          this.setNodeLocationFromNode = utils_1.NOOP;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\n          this.cstPostRule = utils_1.NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = utils_1.NOOP;\n          this.setNodeLocationFromNode = utils_1.NOOP;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = utils_1.NOOP;\n        this.setNodeLocationFromNode = utils_1.NOOP;\n        this.cstPostRule = utils_1.NOOP;\n        this.setInitialNodeLocation = utils_1.NOOP;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n      }\n    }\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\r\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\r\n         * @param cstNode\r\n     */\n\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n    var cstNode = {\n      name: fullRuleName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.CST_STACK.pop();\n  };\n\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    } // \"empty\" CstNode edge case\n    else {\n        loc.startOffset = NaN;\n        loc.startLine = NaN;\n        loc.startColumn = NaN;\n      }\n  };\n\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    } // \"empty\" CstNode edge case\n    else {\n        loc.startOffset = NaN;\n      }\n  };\n\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    cst_1.addTerminalToCst(rootCst, consumedToken, key); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    cst_1.addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if (utils_1.isUndefined(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = cst_visitor_1.createBaseSemanticVisitorConstructor(this.className, utils_1.keys(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n\n    return this.baseCstVisitorConstructor;\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if (utils_1.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = cst_visitor_1.createBaseVisitorConstructorWithDefaults(this.className, utils_1.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n\n  return TreeBuilder;\n}();\n\nexports.TreeBuilder = TreeBuilder;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/tree_builder.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,KAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAMA,IAAA,OAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AAaA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AAEA;;AAEG;;;AACH,IAAA,WAAA;AAAA;AAAA,YAAA;AAAA,WAAA,WAAA,GAAA,CAyPC;;AArOC,EAAA,WAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAqC,MAArC,EAA0D;AACxD,SAAK,SAAL,GAAiB,EAAjB,CADwD,CAGxD;;AACA,SAAK,SAAL,GAAkB,MAAc,CAAC,SAAjC;AAEA,SAAK,oBAAL,GAA4B,OAAA,CAAA,GAAA,CAAI,MAAJ,EAAY,sBAAZ,IACxB,MAAM,CAAC,oBADiB,GAExB,QAAA,CAAA,qBAAA,CAAsB,oBAF1B;;AAIA,QAAI,CAAC,KAAK,SAAV,EAAqB;AACnB,WAAK,wBAAL,GAAgC,OAAA,CAAA,IAAhC;AACA,WAAK,qBAAL,GAA6B,OAAA,CAAA,IAA7B;AACA,WAAK,eAAL,GAAuB,OAAA,CAAA,IAAvB;AACA,WAAK,kBAAL,GAA0B,OAAA,CAAA,IAA1B;AACA,WAAK,WAAL,GAAmB,OAAA,CAAA,IAAnB;AACD,KAND,MAMO;AACL,UAAI,QAAQ,IAAR,CAAa,KAAK,oBAAlB,CAAJ,EAA6C;AAC3C,YAAI,KAAK,eAAT,EAA0B;AACxB,eAAK,wBAAL,GAAgC,KAAA,CAAA,mBAAhC;AACA,eAAK,uBAAL,GAA+B,KAAA,CAAA,mBAA/B;AACA,eAAK,WAAL,GAAmB,OAAA,CAAA,IAAnB;AACA,eAAK,sBAAL,GAA8B,KAAK,kCAAnC;AACD,SALD,MAKO;AACL,eAAK,wBAAL,GAAgC,OAAA,CAAA,IAAhC;AACA,eAAK,uBAAL,GAA+B,OAAA,CAAA,IAA/B;AACA,eAAK,WAAL,GAAmB,KAAK,eAAxB;AACA,eAAK,sBAAL,GAA8B,KAAK,iCAAnC;AACD;AACF,OAZD,MAYO,IAAI,cAAc,IAAd,CAAmB,KAAK,oBAAxB,CAAJ,EAAmD;AACxD,YAAI,KAAK,eAAT,EAA0B;AACxB,eAAK,wBAAL,GAAqC,KAAA,CAAA,yBAArC;AACA,eAAK,uBAAL,GAAoC,KAAA,CAAA,yBAApC;AACA,eAAK,WAAL,GAAmB,OAAA,CAAA,IAAnB;AACA,eAAK,sBAAL,GAA8B,KAAK,wCAAnC;AACD,SALD,MAKO;AACL,eAAK,wBAAL,GAAgC,OAAA,CAAA,IAAhC;AACA,eAAK,uBAAL,GAA+B,OAAA,CAAA,IAA/B;AACA,eAAK,WAAL,GAAmB,KAAK,qBAAxB;AACA,eAAK,sBAAL,GAA8B,KAAK,uCAAnC;AACD;AACF,OAZM,MAYA,IAAI,QAAQ,IAAR,CAAa,KAAK,oBAAlB,CAAJ,EAA6C;AAClD,aAAK,wBAAL,GAAgC,OAAA,CAAA,IAAhC;AACA,aAAK,uBAAL,GAA+B,OAAA,CAAA,IAA/B;AACA,aAAK,WAAL,GAAmB,OAAA,CAAA,IAAnB;AACA,aAAK,sBAAL,GAA8B,OAAA,CAAA,IAA9B;AACD,OALM,MAKA;AACL,cAAM,KAAK,CACT,qDAAkD,MAAM,CAAC,oBAAzD,GAA6E,IADpE,CAAX;AAGD;AACF;AACF,GApDD;;AAsDA,EAAA,WAAA,CAAA,SAAA,CAAA,wCAAA,GAAA,UAEE,OAFF,EAEc;AAEZ,IAAA,OAAO,CAAC,QAAR,GAAmB;AACjB,MAAA,WAAW,EAAE,GADI;AAEjB,MAAA,SAAS,EAAE;AAFM,KAAnB;AAID,GARD;;AAUA,EAAA,WAAA,CAAA,SAAA,CAAA,uCAAA,GAAA,UAEE,OAFF,EAEc;AAEZ,IAAA,OAAO,CAAC,QAAR,GAAmB;AACjB;AACA;AACA;AACA;AACA,MAAA,WAAW,EAAE,KAAK,EAAL,CAAQ,CAAR,EAAW,WALP;AAMjB,MAAA,SAAS,EAAE;AANM,KAAnB;AAQD,GAZD;;AAcA,EAAA,WAAA,CAAA,SAAA,CAAA,kCAAA,GAAA,UAAwD,OAAxD,EAAoE;AAClE,IAAA,OAAO,CAAC,QAAR,GAAmB;AACjB,MAAA,WAAW,EAAE,GADI;AAEjB,MAAA,SAAS,EAAE,GAFM;AAGjB,MAAA,WAAW,EAAE,GAHI;AAIjB,MAAA,SAAS,EAAE,GAJM;AAKjB,MAAA,OAAO,EAAE,GALQ;AAMjB,MAAA,SAAS,EAAE;AANM,KAAnB;AAQD,GATD;AAWA;;;;;;AAKA,EAAA,WAAA,CAAA,SAAA,CAAA,iCAAA,GAAA,UAAuD,OAAvD,EAAmE;AACjE,QAAM,SAAS,GAAG,KAAK,EAAL,CAAQ,CAAR,CAAlB;AACA,IAAA,OAAO,CAAC,QAAR,GAAmB;AACjB,MAAA,WAAW,EAAE,SAAS,CAAC,WADN;AAEjB,MAAA,SAAS,EAAE,SAAS,CAAC,SAFJ;AAGjB,MAAA,WAAW,EAAE,SAAS,CAAC,WAHN;AAIjB,MAAA,SAAS,EAAE,GAJM;AAKjB,MAAA,OAAO,EAAE,GALQ;AAMjB,MAAA,SAAS,EAAE;AANM,KAAnB;AAQD,GAVD;;AAYA,EAAA,WAAA,CAAA,SAAA,CAAA,wBAAA,GAAA,UAEE,YAFF,EAGE,SAHF,EAG4B;AAE1B,QAAM,OAAO,GAAY;AACvB,MAAA,IAAI,EAAE,YADiB;AAEvB,MAAA,QAAQ,EAAE;AAFa,KAAzB;AAKA,SAAK,sBAAL,CAA4B,OAA5B;AACA,SAAK,SAAL,CAAe,IAAf,CAAoB,OAApB;AACD,GAZD;;AAcA,EAAA,WAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,YAAA;AACE,SAAK,SAAL,CAAe,GAAf;AACD,GAFD;;AAIA,EAAA,WAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAqC,WAArC,EAAyD;AACvD,QAAM,SAAS,GAAG,KAAK,EAAL,CAAQ,CAAR,CAAlB;AACA,QAAM,GAAG,GAAG,WAAW,CAAC,QAAxB,CAFuD,CAIvD;AACA;;AACA,QAAI,GAAG,CAAC,WAAJ,IAAmB,SAAS,CAAC,WAA7B,KAA6C,IAAjD,EAAuD;AACrD,MAAA,GAAG,CAAC,SAAJ,GAAgB,SAAS,CAAC,SAA1B;AACA,MAAA,GAAG,CAAC,OAAJ,GAAc,SAAS,CAAC,OAAxB;AACA,MAAA,GAAG,CAAC,SAAJ,GAAgB,SAAS,CAAC,SAA1B;AACD,KAJD,CAKA;AALA,SAMK;AACH,QAAA,GAAG,CAAC,WAAJ,GAAkB,GAAlB;AACA,QAAA,GAAG,CAAC,SAAJ,GAAgB,GAAhB;AACA,QAAA,GAAG,CAAC,WAAJ,GAAkB,GAAlB;AACD;AACF,GAjBD;;AAmBA,EAAA,WAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAA2C,WAA3C,EAA+D;AAC7D,QAAM,SAAS,GAAG,KAAK,EAAL,CAAQ,CAAR,CAAlB;AACA,QAAM,GAAG,GAAG,WAAW,CAAC,QAAxB,CAF6D,CAI7D;AACA;;AACA,QAAI,GAAG,CAAC,WAAJ,IAAmB,SAAS,CAAC,WAA7B,KAA6C,IAAjD,EAAuD;AACrD,MAAA,GAAG,CAAC,SAAJ,GAAgB,SAAS,CAAC,SAA1B;AACD,KAFD,CAGA;AAHA,SAIK;AACH,QAAA,GAAG,CAAC,WAAJ,GAAkB,GAAlB;AACD;AACF,GAbD;;AAeA,EAAA,WAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAEE,GAFF,EAGE,aAHF,EAGuB;AAErB,QAAM,OAAO,GAAG,KAAK,SAAL,CAAe,KAAK,SAAL,CAAe,MAAf,GAAwB,CAAvC,CAAhB;AACA,IAAA,KAAA,CAAA,gBAAA,CAAiB,OAAjB,EAA0B,aAA1B,EAAyC,GAAzC,EAHqB,CAIrB;;AACA,SAAK,wBAAL,CAA8B,OAAO,CAAC,QAAtC,EAAqD,aAArD;AACD,GATD;;AAWA,EAAA,WAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAEE,aAFF,EAGE,QAHF,EAGkB;AAEhB,QAAM,UAAU,GAAG,KAAK,SAAL,CAAe,KAAK,SAAL,CAAe,MAAf,GAAwB,CAAvC,CAAnB;AACA,IAAA,KAAA,CAAA,oBAAA,CAAqB,UAArB,EAAiC,QAAjC,EAA2C,aAA3C,EAHgB,CAIhB;;AACA,SAAK,uBAAL,CAA6B,UAAU,CAAC,QAAxC,EAAkD,aAAa,CAAC,QAAhE;AACD,GATD;;AAWA,EAAA,WAAA,CAAA,SAAA,CAAA,4BAAA,GAAA,YAAA;AAKE,QAAI,OAAA,CAAA,WAAA,CAAY,KAAK,yBAAjB,CAAJ,EAAiD;AAC/C,UAAM,4BAA4B,GAAG,aAAA,CAAA,oCAAA,CACnC,KAAK,SAD8B,EAEnC,OAAA,CAAA,IAAA,CAAK,KAAK,oBAAV,CAFmC,CAArC;AAIA,WAAK,yBAAL,GAAiC,4BAAjC;AACA,aAAO,4BAAP;AACD;;AAED,WAAY,KAAK,yBAAjB;AACD,GAfD;;AAiBA,EAAA,WAAA,CAAA,SAAA,CAAA,wCAAA,GAAA,YAAA;AAKE,QAAI,OAAA,CAAA,WAAA,CAAY,KAAK,qCAAjB,CAAJ,EAA6D;AAC3D,UAAM,cAAc,GAAG,aAAA,CAAA,wCAAA,CACrB,KAAK,SADgB,EAErB,OAAA,CAAA,IAAA,CAAK,KAAK,oBAAV,CAFqB,EAGrB,KAAK,4BAAL,EAHqB,CAAvB;AAKA,WAAK,qCAAL,GAA6C,cAA7C;AACA,aAAO,cAAP;AACD;;AAED,WAAY,KAAK,qCAAjB;AACD,GAhBD;;AAkBA,EAAA,WAAA,CAAA,SAAA,CAAA,4BAAA,GAAA,YAAA;AACE,QAAM,SAAS,GAAG,KAAK,UAAvB;AACA,WAAO,SAAS,CAAC,SAAS,CAAC,MAAV,GAAmB,CAApB,CAAhB;AACD,GAHD;;AAKA,EAAA,WAAA,CAAA,SAAA,CAAA,gCAAA,GAAA,YAAA;AACE,QAAM,SAAS,GAAG,KAAK,UAAvB;AACA,WAAO,SAAS,CAAC,SAAS,CAAC,MAAV,GAAmB,CAApB,CAAhB;AACD,GAHD;;AAKA,EAAA,WAAA,CAAA,SAAA,CAAA,kCAAA,GAAA,YAAA;AACE,QAAM,eAAe,GAAG,KAAK,qBAA7B;AACA,WAAO,eAAe,CAAC,eAAe,CAAC,MAAhB,GAAyB,CAA1B,CAAtB;AACD,GAHD;;AAIF,SAAA,WAAA;AAAC,CAzPD,EAAA;;AAAa,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TreeBuilder = void 0;\r\nvar cst_1 = require(\"../../cst/cst\");\r\nvar utils_1 = require(\"@chevrotain/utils\");\r\nvar cst_visitor_1 = require(\"../../cst/cst_visitor\");\r\nvar parser_1 = require(\"../parser\");\r\n/**\r\n * This trait is responsible for the CST building logic.\r\n */\r\nvar TreeBuilder = /** @class */ (function () {\r\n    function TreeBuilder() {\r\n    }\r\n    TreeBuilder.prototype.initTreeBuilder = function (config) {\r\n        this.CST_STACK = [];\r\n        // outputCst is no longer exposed/defined in the pubic API\r\n        this.outputCst = config.outputCst;\r\n        this.nodeLocationTracking = utils_1.has(config, \"nodeLocationTracking\")\r\n            ? config.nodeLocationTracking\r\n            : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\r\n        if (!this.outputCst) {\r\n            this.cstInvocationStateUpdate = utils_1.NOOP;\r\n            this.cstFinallyStateUpdate = utils_1.NOOP;\r\n            this.cstPostTerminal = utils_1.NOOP;\r\n            this.cstPostNonTerminal = utils_1.NOOP;\r\n            this.cstPostRule = utils_1.NOOP;\r\n        }\r\n        else {\r\n            if (/full/i.test(this.nodeLocationTracking)) {\r\n                if (this.recoveryEnabled) {\r\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\r\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\r\n                    this.cstPostRule = utils_1.NOOP;\r\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\r\n                }\r\n                else {\r\n                    this.setNodeLocationFromToken = utils_1.NOOP;\r\n                    this.setNodeLocationFromNode = utils_1.NOOP;\r\n                    this.cstPostRule = this.cstPostRuleFull;\r\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\r\n                }\r\n            }\r\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\r\n                if (this.recoveryEnabled) {\r\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\r\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\r\n                    this.cstPostRule = utils_1.NOOP;\r\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\r\n                }\r\n                else {\r\n                    this.setNodeLocationFromToken = utils_1.NOOP;\r\n                    this.setNodeLocationFromNode = utils_1.NOOP;\r\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\r\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\r\n                }\r\n            }\r\n            else if (/none/i.test(this.nodeLocationTracking)) {\r\n                this.setNodeLocationFromToken = utils_1.NOOP;\r\n                this.setNodeLocationFromNode = utils_1.NOOP;\r\n                this.cstPostRule = utils_1.NOOP;\r\n                this.setInitialNodeLocation = utils_1.NOOP;\r\n            }\r\n            else {\r\n                throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\r\n            }\r\n        }\r\n    };\r\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\r\n        cstNode.location = {\r\n            startOffset: NaN,\r\n            endOffset: NaN\r\n        };\r\n    };\r\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\r\n        cstNode.location = {\r\n            // without error recovery the starting Location of a new CstNode is guaranteed\r\n            // To be the next Token's startOffset (for valid inputs).\r\n            // For invalid inputs there won't be any CSTOutput so this potential\r\n            // inaccuracy does not matter\r\n            startOffset: this.LA(1).startOffset,\r\n            endOffset: NaN\r\n        };\r\n    };\r\n    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\r\n        cstNode.location = {\r\n            startOffset: NaN,\r\n            startLine: NaN,\r\n            startColumn: NaN,\r\n            endOffset: NaN,\r\n            endLine: NaN,\r\n            endColumn: NaN\r\n        };\r\n    };\r\n    /**\r\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\r\n  \r\n       * @param cstNode\r\n       */\r\n    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\r\n        var nextToken = this.LA(1);\r\n        cstNode.location = {\r\n            startOffset: nextToken.startOffset,\r\n            startLine: nextToken.startLine,\r\n            startColumn: nextToken.startColumn,\r\n            endOffset: NaN,\r\n            endLine: NaN,\r\n            endColumn: NaN\r\n        };\r\n    };\r\n    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\r\n        var cstNode = {\r\n            name: fullRuleName,\r\n            children: {}\r\n        };\r\n        this.setInitialNodeLocation(cstNode);\r\n        this.CST_STACK.push(cstNode);\r\n    };\r\n    TreeBuilder.prototype.cstFinallyStateUpdate = function () {\r\n        this.CST_STACK.pop();\r\n    };\r\n    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\r\n        var prevToken = this.LA(0);\r\n        var loc = ruleCstNode.location;\r\n        // If this condition is true it means we consumed at least one Token\r\n        // In this CstNode.\r\n        if (loc.startOffset <= prevToken.startOffset === true) {\r\n            loc.endOffset = prevToken.endOffset;\r\n            loc.endLine = prevToken.endLine;\r\n            loc.endColumn = prevToken.endColumn;\r\n        }\r\n        // \"empty\" CstNode edge case\r\n        else {\r\n            loc.startOffset = NaN;\r\n            loc.startLine = NaN;\r\n            loc.startColumn = NaN;\r\n        }\r\n    };\r\n    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\r\n        var prevToken = this.LA(0);\r\n        var loc = ruleCstNode.location;\r\n        // If this condition is true it means we consumed at least one Token\r\n        // In this CstNode.\r\n        if (loc.startOffset <= prevToken.startOffset === true) {\r\n            loc.endOffset = prevToken.endOffset;\r\n        }\r\n        // \"empty\" CstNode edge case\r\n        else {\r\n            loc.startOffset = NaN;\r\n        }\r\n    };\r\n    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\r\n        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\r\n        cst_1.addTerminalToCst(rootCst, consumedToken, key);\r\n        // This is only used when **both** error recovery and CST Output are enabled.\r\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\r\n    };\r\n    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\r\n        var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\r\n        cst_1.addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\r\n        // This is only used when **both** error recovery and CST Output are enabled.\r\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\r\n    };\r\n    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\r\n        if (utils_1.isUndefined(this.baseCstVisitorConstructor)) {\r\n            var newBaseCstVisitorConstructor = cst_visitor_1.createBaseSemanticVisitorConstructor(this.className, utils_1.keys(this.gastProductionsCache));\r\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\r\n            return newBaseCstVisitorConstructor;\r\n        }\r\n        return this.baseCstVisitorConstructor;\r\n    };\r\n    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\r\n        if (utils_1.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\r\n            var newConstructor = cst_visitor_1.createBaseVisitorConstructorWithDefaults(this.className, utils_1.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\r\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\r\n            return newConstructor;\r\n        }\r\n        return this.baseCstVisitorWithDefaultsConstructor;\r\n    };\r\n    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\r\n        var ruleStack = this.RULE_STACK;\r\n        return ruleStack[ruleStack.length - 1];\r\n    };\r\n    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\r\n        var ruleStack = this.RULE_STACK;\r\n        return ruleStack[ruleStack.length - 2];\r\n    };\r\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\r\n        var occurrenceStack = this.RULE_OCCURRENCE_STACK;\r\n        return occurrenceStack[occurrenceStack.length - 1];\r\n    };\r\n    return TreeBuilder;\r\n}());\r\nexports.TreeBuilder = TreeBuilder;\r\n//# sourceMappingURL=tree_builder.js.map"]},"metadata":{},"sourceType":"script"}