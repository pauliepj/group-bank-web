{"ast":null,"code":"import { Loader, FileLoader, LineBasicMaterial, Group, Euler, BufferGeometry, Float32BufferAttribute, LineSegments } from 'three';\n/**\r\n * GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\r\n *\r\n * Gcode files are composed by commands used by machines to create objects.\r\n *\r\n * @class GCodeLoader\r\n * @param {Manager} manager Loading manager.\r\n */\n\nclass GCodeLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.splitLayer = false;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data) {\n    let state = {\n      x: 0,\n      y: 0,\n      z: 0,\n      e: 0,\n      f: 0,\n      extruding: false,\n      relative: false\n    };\n    let layers = [];\n    let currentLayer = undefined;\n    const pathMaterial = new LineBasicMaterial({\n      color: 0xff0000\n    });\n    pathMaterial.name = 'path';\n    const extrudingMaterial = new LineBasicMaterial({\n      color: 0x00ff00\n    });\n    extrudingMaterial.name = 'extruded';\n\n    function newLayer(line) {\n      currentLayer = {\n        vertex: [],\n        pathVertex: [],\n        z: line.z\n      };\n      layers.push(currentLayer);\n    } //Create lie segment between p1 and p2\n\n\n    function addSegment(p1, p2) {\n      if (currentLayer === undefined) {\n        newLayer(p1);\n      }\n\n      if (state.extruding) {\n        currentLayer.vertex.push(p1.x, p1.y, p1.z);\n        currentLayer.vertex.push(p2.x, p2.y, p2.z);\n      } else {\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n      }\n    }\n\n    function delta(v1, v2) {\n      return state.relative ? v2 : v2 - v1;\n    }\n\n    function absolute(v1, v2) {\n      return state.relative ? v1 + v2 : v2;\n    }\n\n    let lines = data.replace(/;.+/g, '').split('\\n');\n\n    for (let i = 0; i < lines.length; i++) {\n      let tokens = lines[i].split(' ');\n      let cmd = tokens[0].toUpperCase(); //Argumments\n\n      let args = {};\n      tokens.splice(1).forEach(function (token) {\n        if (token[0] !== undefined) {\n          let key = token[0].toLowerCase();\n          let value = parseFloat(token.substring(1));\n          args[key] = value;\n        }\n      }); //Process commands\n      //G0/G1 – Linear Movement\n\n      if (cmd === 'G0' || cmd === 'G1') {\n        let line = {\n          x: args.x !== undefined ? absolute(state.x, args.x) : state.x,\n          y: args.y !== undefined ? absolute(state.y, args.y) : state.y,\n          z: args.z !== undefined ? absolute(state.z, args.z) : state.z,\n          e: args.e !== undefined ? absolute(state.e, args.e) : state.e,\n          f: args.f !== undefined ? absolute(state.f, args.f) : state.f\n        }; //Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n\n        if (delta(state.e, line.e) > 0) {\n          line.extruding = delta(state.e, line.e) > 0;\n\n          if (currentLayer == undefined || line.z != currentLayer.z) {\n            newLayer(line);\n          }\n        }\n\n        addSegment(state, line);\n        state = line;\n      } else if (cmd === 'G2' || cmd === 'G3') ;else if (cmd === 'G90') {\n        //G90: Set to Absolute Positioning\n        state.relative = false;\n      } else if (cmd === 'G91') {\n        //G91: Set to state.relative Positioning\n        state.relative = true;\n      } else if (cmd === 'G92') {\n        //G92: Set Position\n        let line = state;\n        line.x = args.x !== undefined ? args.x : line.x;\n        line.y = args.y !== undefined ? args.y : line.y;\n        line.z = args.z !== undefined ? args.z : line.z;\n        line.e = args.e !== undefined ? args.e : line.e;\n        state = line;\n      } else ;\n    }\n\n    function addObject(vertex, extruding, i) {\n      let geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(vertex, 3));\n      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n      segments.name = 'layer' + i;\n      object.add(segments);\n    }\n\n    const object = new Group();\n    object.name = 'gcode';\n\n    if (this.splitLayer) {\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        addObject(layer.vertex, true, i);\n        addObject(layer.pathVertex, false, i);\n      }\n    } else {\n      const vertex = [],\n            pathVertex = [];\n\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i];\n        let layerVertex = layer.vertex;\n        let layerPathVertex = layer.pathVertex;\n\n        for (let j = 0; j < layerVertex.length; j++) {\n          vertex.push(layerVertex[j]);\n        }\n\n        for (let j = 0; j < layerPathVertex.length; j++) {\n          pathVertex.push(layerPathVertex[j]);\n        }\n      }\n\n      addObject(vertex, true, layers.length);\n      addObject(pathVertex, false, layers.length);\n    }\n\n    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    return object;\n  }\n\n}\n\nexport { GCodeLoader };","map":{"version":3,"sources":["C:/Users/samue/Documents/REACTworkspace/group-bank-web/node_modules/three-stdlib/loaders/GCodeLoader.js"],"names":["Loader","FileLoader","LineBasicMaterial","Group","Euler","BufferGeometry","Float32BufferAttribute","LineSegments","GCodeLoader","constructor","manager","splitLayer","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","state","x","y","z","f","extruding","relative","layers","currentLayer","undefined","pathMaterial","color","name","extrudingMaterial","newLayer","line","vertex","pathVertex","push","addSegment","p1","p2","delta","v1","v2","absolute","lines","replace","split","i","length","tokens","cmd","toUpperCase","args","splice","forEach","token","key","toLowerCase","value","parseFloat","substring","addObject","geometry","setAttribute","segments","object","add","layer","layerVertex","layerPathVertex","j","quaternion","setFromEuler","Math","PI"],"mappings":"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","sourcesContent":["import { Loader, FileLoader, LineBasicMaterial, Group, Euler, BufferGeometry, Float32BufferAttribute, LineSegments } from 'three';\r\n\r\n/**\r\n * GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\r\n *\r\n * Gcode files are composed by commands used by machines to create objects.\r\n *\r\n * @class GCodeLoader\r\n * @param {Manager} manager Loading manager.\r\n */\r\n\r\nclass GCodeLoader extends Loader {\r\n  constructor(manager) {\r\n    super(manager);\r\n    this.splitLayer = false;\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const scope = this;\r\n    const loader = new FileLoader(scope.manager);\r\n    loader.setPath(scope.path);\r\n    loader.setRequestHeader(scope.requestHeader);\r\n    loader.setWithCredentials(scope.withCredentials);\r\n    loader.load(url, function (text) {\r\n      try {\r\n        onLoad(scope.parse(text));\r\n      } catch (e) {\r\n        if (onError) {\r\n          onError(e);\r\n        } else {\r\n          console.error(e);\r\n        }\r\n\r\n        scope.manager.itemError(url);\r\n      }\r\n    }, onProgress, onError);\r\n  }\r\n\r\n  parse(data) {\r\n    let state = {\r\n      x: 0,\r\n      y: 0,\r\n      z: 0,\r\n      e: 0,\r\n      f: 0,\r\n      extruding: false,\r\n      relative: false\r\n    };\r\n    let layers = [];\r\n    let currentLayer = undefined;\r\n    const pathMaterial = new LineBasicMaterial({\r\n      color: 0xff0000\r\n    });\r\n    pathMaterial.name = 'path';\r\n    const extrudingMaterial = new LineBasicMaterial({\r\n      color: 0x00ff00\r\n    });\r\n    extrudingMaterial.name = 'extruded';\r\n\r\n    function newLayer(line) {\r\n      currentLayer = {\r\n        vertex: [],\r\n        pathVertex: [],\r\n        z: line.z\r\n      };\r\n      layers.push(currentLayer);\r\n    } //Create lie segment between p1 and p2\r\n\r\n\r\n    function addSegment(p1, p2) {\r\n      if (currentLayer === undefined) {\r\n        newLayer(p1);\r\n      }\r\n\r\n      if (state.extruding) {\r\n        currentLayer.vertex.push(p1.x, p1.y, p1.z);\r\n        currentLayer.vertex.push(p2.x, p2.y, p2.z);\r\n      } else {\r\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z);\r\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z);\r\n      }\r\n    }\r\n\r\n    function delta(v1, v2) {\r\n      return state.relative ? v2 : v2 - v1;\r\n    }\r\n\r\n    function absolute(v1, v2) {\r\n      return state.relative ? v1 + v2 : v2;\r\n    }\r\n\r\n    let lines = data.replace(/;.+/g, '').split('\\n');\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n      let tokens = lines[i].split(' ');\r\n      let cmd = tokens[0].toUpperCase(); //Argumments\r\n\r\n      let args = {};\r\n      tokens.splice(1).forEach(function (token) {\r\n        if (token[0] !== undefined) {\r\n          let key = token[0].toLowerCase();\r\n          let value = parseFloat(token.substring(1));\r\n          args[key] = value;\r\n        }\r\n      }); //Process commands\r\n      //G0/G1 – Linear Movement\r\n\r\n      if (cmd === 'G0' || cmd === 'G1') {\r\n        let line = {\r\n          x: args.x !== undefined ? absolute(state.x, args.x) : state.x,\r\n          y: args.y !== undefined ? absolute(state.y, args.y) : state.y,\r\n          z: args.z !== undefined ? absolute(state.z, args.z) : state.z,\r\n          e: args.e !== undefined ? absolute(state.e, args.e) : state.e,\r\n          f: args.f !== undefined ? absolute(state.f, args.f) : state.f\r\n        }; //Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\r\n\r\n        if (delta(state.e, line.e) > 0) {\r\n          line.extruding = delta(state.e, line.e) > 0;\r\n\r\n          if (currentLayer == undefined || line.z != currentLayer.z) {\r\n            newLayer(line);\r\n          }\r\n        }\r\n\r\n        addSegment(state, line);\r\n        state = line;\r\n      } else if (cmd === 'G2' || cmd === 'G3') ; else if (cmd === 'G90') {\r\n        //G90: Set to Absolute Positioning\r\n        state.relative = false;\r\n      } else if (cmd === 'G91') {\r\n        //G91: Set to state.relative Positioning\r\n        state.relative = true;\r\n      } else if (cmd === 'G92') {\r\n        //G92: Set Position\r\n        let line = state;\r\n        line.x = args.x !== undefined ? args.x : line.x;\r\n        line.y = args.y !== undefined ? args.y : line.y;\r\n        line.z = args.z !== undefined ? args.z : line.z;\r\n        line.e = args.e !== undefined ? args.e : line.e;\r\n        state = line;\r\n      } else ;\r\n    }\r\n\r\n    function addObject(vertex, extruding, i) {\r\n      let geometry = new BufferGeometry();\r\n      geometry.setAttribute('position', new Float32BufferAttribute(vertex, 3));\r\n      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\r\n      segments.name = 'layer' + i;\r\n      object.add(segments);\r\n    }\r\n\r\n    const object = new Group();\r\n    object.name = 'gcode';\r\n\r\n    if (this.splitLayer) {\r\n      for (let i = 0; i < layers.length; i++) {\r\n        let layer = layers[i];\r\n        addObject(layer.vertex, true, i);\r\n        addObject(layer.pathVertex, false, i);\r\n      }\r\n    } else {\r\n      const vertex = [],\r\n            pathVertex = [];\r\n\r\n      for (let i = 0; i < layers.length; i++) {\r\n        let layer = layers[i];\r\n        let layerVertex = layer.vertex;\r\n        let layerPathVertex = layer.pathVertex;\r\n\r\n        for (let j = 0; j < layerVertex.length; j++) {\r\n          vertex.push(layerVertex[j]);\r\n        }\r\n\r\n        for (let j = 0; j < layerPathVertex.length; j++) {\r\n          pathVertex.push(layerPathVertex[j]);\r\n        }\r\n      }\r\n\r\n      addObject(vertex, true, layers.length);\r\n      addObject(pathVertex, false, layers.length);\r\n    }\r\n\r\n    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\r\n    return object;\r\n  }\r\n\r\n}\r\n\r\nexport { GCodeLoader };\r\n"]},"metadata":{},"sourceType":"module"}