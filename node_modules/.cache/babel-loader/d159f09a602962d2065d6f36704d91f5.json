{"ast":null,"code":"\"use strict\";\n/* istanbul ignore next */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nextPossibleTokensAfter = exports.possiblePathsFrom = exports.NextTerminalAfterAtLeastOneSepWalker = exports.NextTerminalAfterAtLeastOneWalker = exports.NextTerminalAfterManySepWalker = exports.NextTerminalAfterManyWalker = exports.AbstractNextTerminalAfterProductionWalker = exports.NextAfterTokenWalker = exports.AbstractNextPossibleTokensWalker = void 0;\n\nvar rest_1 = require(\"./rest\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar first_1 = require(\"./first\");\n\nvar gast_public_1 = require(\"./gast/gast_public\");\n\nvar AbstractNextPossibleTokensWalker =\n/** @class */\nfunction (_super) {\n  __extends(AbstractNextPossibleTokensWalker, _super);\n\n  function AbstractNextPossibleTokensWalker(topProd, path) {\n    var _this = _super.call(this)\n    /* istanbul ignore next */\n    || this;\n\n    _this.topProd = topProd;\n    _this.path = path;\n    _this.possibleTokTypes = [];\n    _this.nextProductionName = \"\";\n    _this.nextProductionOccurrence = 0;\n    _this.found = false;\n    _this.isAtEndOfPath = false;\n    return _this;\n  }\n\n  AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n    this.found = false;\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    } // immutable for the win\n\n\n    this.ruleStack = utils_1.cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\n\n    this.occurrenceStack = utils_1.cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n    // already verified that the first production is valid, we now seek the 2nd production\n\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n    if (prevRest === void 0) {\n      prevRest = [];\n    } // stop scanning once we found the path\n\n\n    if (!this.found) {\n      _super.prototype.walk.call(this, prod, prevRest);\n    }\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n    // found the next production, need to keep walking in it\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      var fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n    // need to consume the Terminal\n    if (utils_1.isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  };\n\n  return AbstractNextPossibleTokensWalker;\n}(rest_1.RestWalker);\n\nexports.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;\n\nvar NextAfterTokenWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextAfterTokenWalker, _super);\n\n  function NextAfterTokenWalker(topProd, path) {\n    var _this = _super.call(this, topProd, path)\n    /* istanbul ignore next */\n    || this;\n\n    _this.path = path;\n    _this.nextTerminalName = \"\";\n    _this.nextTerminalOccurrence = 0;\n    _this.nextTerminalName = _this.path.lastTok.name;\n    _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n    return _this;\n  }\n\n  NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      var fullRest = currRest.concat(prevRest);\n      var restProd = new gast_public_1.Alternative({\n        definition: fullRest\n      });\n      this.possibleTokTypes = first_1.first(restProd);\n      this.found = true;\n    }\n  };\n\n  return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker);\n\nexports.NextAfterTokenWalker = NextAfterTokenWalker;\n/**\r\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\r\n * it never \"follows\" production refs\r\n */\n\nvar AbstractNextTerminalAfterProductionWalker =\n/** @class */\nfunction (_super) {\n  __extends(AbstractNextTerminalAfterProductionWalker, _super);\n\n  function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n    var _this = _super.call(this)\n    /* istanbul ignore next */\n    || this;\n\n    _this.topRule = topRule;\n    _this.occurrence = occurrence;\n    _this.result = {\n      token: undefined,\n      occurrence: undefined,\n      isEndOfRule: undefined\n    };\n    return _this;\n  }\n\n  AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n    this.walk(this.topRule);\n    return this.result;\n  };\n\n  return AbstractNextTerminalAfterProductionWalker;\n}(rest_1.RestWalker);\n\nexports.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;\n\nvar NextTerminalAfterManyWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterManyWalker, _super);\n\n  function NextTerminalAfterManyWalker() {\n    return _super !== null && _super.apply(this, arguments)\n    /* istanbul ignore next */\n    || this;\n  }\n\n  NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      var firstAfterMany = utils_1.first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === undefined;\n\n      if (firstAfterMany instanceof gast_public_1.Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexports.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;\n\nvar NextTerminalAfterManySepWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterManySepWalker, _super);\n\n  function NextTerminalAfterManySepWalker() {\n    return _super !== null && _super.apply(this, arguments)\n    /* istanbul ignore next */\n    || this;\n  }\n\n  NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      var firstAfterManySep = utils_1.first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n\n      if (firstAfterManySep instanceof gast_public_1.Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexports.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;\n\nvar NextTerminalAfterAtLeastOneWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterAtLeastOneWalker, _super);\n\n  function NextTerminalAfterAtLeastOneWalker() {\n    return _super !== null && _super.apply(this, arguments)\n    /* istanbul ignore next */\n    || this;\n  }\n\n  NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      var firstAfterAtLeastOne = utils_1.first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n\n      if (firstAfterAtLeastOne instanceof gast_public_1.Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexports.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker; // TODO: reduce code duplication in the AfterWalkers\n\nvar NextTerminalAfterAtLeastOneSepWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n\n  function NextTerminalAfterAtLeastOneSepWalker() {\n    return _super !== null && _super.apply(this, arguments)\n    /* istanbul ignore next */\n    || this;\n  }\n\n  NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      var firstAfterfirstAfterAtLeastOneSep = utils_1.first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n\n      if (firstAfterfirstAfterAtLeastOneSep instanceof gast_public_1.Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexports.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;\n\nfunction possiblePathsFrom(targetDef, maxLength, currPath) {\n  if (currPath === void 0) {\n    currPath = [];\n  } // avoid side effects\n\n\n  currPath = utils_1.cloneArr(currPath);\n  var result = [];\n  var i = 0; // TODO: avoid inner funcs\n\n  function remainingPathWith(nextDef) {\n    return nextDef.concat(utils_1.drop(targetDef, i + 1));\n  } // TODO: avoid inner funcs\n\n\n  function getAlternativesForProd(definition) {\n    var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  /**\r\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\r\n   * following (rest) of the targetDef.\r\n   *\r\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\r\n   * the optional production.\r\n   */\n\n\n  while (currPath.length < maxLength && i < targetDef.length) {\n    var prod = targetDef[i];\n    /* istanbul ignore else */\n\n    if (prod instanceof gast_public_1.Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof gast_public_1.NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof gast_public_1.Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof gast_public_1.RepetitionMandatory) {\n      var newDef = prod.definition.concat([new gast_public_1.Repetition({\n        definition: prod.definition\n      })]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\n      var newDef = [new gast_public_1.Alternative({\n        definition: prod.definition\n      }), new gast_public_1.Repetition({\n        definition: [new gast_public_1.Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\n      var newDef = prod.definition.concat([new gast_public_1.Repetition({\n        definition: [new gast_public_1.Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_public_1.Repetition) {\n      var newDef = prod.definition.concat([new gast_public_1.Repetition({\n        definition: prod.definition\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_public_1.Alternation) {\n      utils_1.forEach(prod.definition, function (currAlt) {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (utils_1.isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof gast_public_1.Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n\n    i++;\n  }\n\n  result.push({\n    partialPath: currPath,\n    suffixDef: utils_1.drop(targetDef, i)\n  });\n  return result;\n}\n\nexports.possiblePathsFrom = possiblePathsFrom;\n\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\"; // to avoid creating a new Array each time.\n\n  var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  var foundCompletePath = false;\n  var tokenVectorLength = tokenVector.length;\n  var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  var result = [];\n  var possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n\n  while (!utils_1.isEmpty(possiblePaths)) {\n    var currPath = possiblePaths.pop(); // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && utils_1.last(possiblePaths).idx <= minimalAlternativesIndex) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n\n      continue;\n    }\n\n    var currDef = currPath.def;\n    var currIdx = currPath.idx;\n    var currRuleStack = currPath.ruleStack;\n    var currOccurrenceStack = currPath.occurrenceStack; // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n\n    if (utils_1.isEmpty(currDef)) {\n      continue;\n    }\n\n    var prod = currDef[0];\n    /* istanbul ignore else */\n\n    if (prod === EXIT_NON_TERMINAL) {\n      var nextPath = {\n        idx: currIdx,\n        def: utils_1.drop(currDef),\n        ruleStack: utils_1.dropRight(currRuleStack),\n        occurrenceStack: utils_1.dropRight(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_public_1.Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        var nextIdx = currIdx + 1;\n        var actualToken = tokenVector[nextIdx];\n\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          var nextPath = {\n            idx: nextIdx,\n            def: utils_1.drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        } // end of the line\n\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof gast_public_1.NonTerminal) {\n      var newRuleStack = utils_1.cloneArr(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      var newOccurrenceStack = utils_1.cloneArr(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      var nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, utils_1.drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_public_1.Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: utils_1.drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(utils_1.drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof gast_public_1.RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var secondIteration = new gast_public_1.Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var separatorGast = new gast_public_1.Terminal({\n        terminalType: prod.separator\n      });\n      var secondIteration = new gast_public_1.Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: utils_1.drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var separatorGast = new gast_public_1.Terminal({\n        terminalType: prod.separator\n      });\n      var nthRepetition = new gast_public_1.Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof gast_public_1.Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: utils_1.drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE); // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n\n      var nthRepetition = new gast_public_1.Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof gast_public_1.Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (var i = prod.definition.length - 1; i >= 0; i--) {\n        var currAlt = prod.definition[i];\n        var currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(utils_1.drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof gast_public_1.Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(utils_1.drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof gast_public_1.Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n\n  return result;\n}\n\nexports.nextPossibleTokensAfter = nextPossibleTokensAfter;\n\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  var newRuleStack = utils_1.cloneArr(currRuleStack);\n  newRuleStack.push(topRule.name);\n  var newCurrOccurrenceStack = utils_1.cloneArr(currOccurrenceStack); // top rule is always assumed to have been called with occurrence index 1\n\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}","map":{"version":3,"sources":["../../../../src/parse/grammar/interpreter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/* istanbul ignore next */ var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.nextPossibleTokensAfter = exports.possiblePathsFrom = exports.NextTerminalAfterAtLeastOneSepWalker = exports.NextTerminalAfterAtLeastOneWalker = exports.NextTerminalAfterManySepWalker = exports.NextTerminalAfterManyWalker = exports.AbstractNextTerminalAfterProductionWalker = exports.NextAfterTokenWalker = exports.AbstractNextPossibleTokensWalker = void 0;\r\nvar rest_1 = require(\"./rest\");\r\nvar utils_1 = require(\"@chevrotain/utils\");\r\nvar first_1 = require(\"./first\");\r\nvar gast_public_1 = require(\"./gast/gast_public\");\r\nvar AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {\r\n    __extends(AbstractNextPossibleTokensWalker, _super);\r\n    function AbstractNextPossibleTokensWalker(topProd, path) {\r\n        var _this = _super.call(this) /* istanbul ignore next */ || this;\r\n        _this.topProd = topProd;\r\n        _this.path = path;\r\n        _this.possibleTokTypes = [];\r\n        _this.nextProductionName = \"\";\r\n        _this.nextProductionOccurrence = 0;\r\n        _this.found = false;\r\n        _this.isAtEndOfPath = false;\r\n        return _this;\r\n    }\r\n    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\r\n        this.found = false;\r\n        if (this.path.ruleStack[0] !== this.topProd.name) {\r\n            throw Error(\"The path does not start with the walker's top Rule!\");\r\n        }\r\n        // immutable for the win\r\n        this.ruleStack = utils_1.cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\r\n        this.occurrenceStack = utils_1.cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\r\n        // already verified that the first production is valid, we now seek the 2nd production\r\n        this.ruleStack.pop();\r\n        this.occurrenceStack.pop();\r\n        this.updateExpectedNext();\r\n        this.walk(this.topProd);\r\n        return this.possibleTokTypes;\r\n    };\r\n    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\r\n        if (prevRest === void 0) { prevRest = []; }\r\n        // stop scanning once we found the path\r\n        if (!this.found) {\r\n            _super.prototype.walk.call(this, prod, prevRest);\r\n        }\r\n    };\r\n    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\r\n        // found the next production, need to keep walking in it\r\n        if (refProd.referencedRule.name === this.nextProductionName &&\r\n            refProd.idx === this.nextProductionOccurrence) {\r\n            var fullRest = currRest.concat(prevRest);\r\n            this.updateExpectedNext();\r\n            this.walk(refProd.referencedRule, fullRest);\r\n        }\r\n    };\r\n    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\r\n        // need to consume the Terminal\r\n        if (utils_1.isEmpty(this.ruleStack)) {\r\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\r\n            // really seeking is the last Terminal...\r\n            this.nextProductionName = \"\";\r\n            this.nextProductionOccurrence = 0;\r\n            this.isAtEndOfPath = true;\r\n        }\r\n        else {\r\n            this.nextProductionName = this.ruleStack.pop();\r\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\r\n        }\r\n    };\r\n    return AbstractNextPossibleTokensWalker;\r\n}(rest_1.RestWalker));\r\nexports.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;\r\nvar NextAfterTokenWalker = /** @class */ (function (_super) {\r\n    __extends(NextAfterTokenWalker, _super);\r\n    function NextAfterTokenWalker(topProd, path) {\r\n        var _this = _super.call(this, topProd, path) /* istanbul ignore next */ || this;\r\n        _this.path = path;\r\n        _this.nextTerminalName = \"\";\r\n        _this.nextTerminalOccurrence = 0;\r\n        _this.nextTerminalName = _this.path.lastTok.name;\r\n        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\r\n        return _this;\r\n    }\r\n    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\r\n        if (this.isAtEndOfPath &&\r\n            terminal.terminalType.name === this.nextTerminalName &&\r\n            terminal.idx === this.nextTerminalOccurrence &&\r\n            !this.found) {\r\n            var fullRest = currRest.concat(prevRest);\r\n            var restProd = new gast_public_1.Alternative({ definition: fullRest });\r\n            this.possibleTokTypes = first_1.first(restProd);\r\n            this.found = true;\r\n        }\r\n    };\r\n    return NextAfterTokenWalker;\r\n}(AbstractNextPossibleTokensWalker));\r\nexports.NextAfterTokenWalker = NextAfterTokenWalker;\r\n/**\r\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\r\n * it never \"follows\" production refs\r\n */\r\nvar AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {\r\n    __extends(AbstractNextTerminalAfterProductionWalker, _super);\r\n    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\r\n        var _this = _super.call(this) /* istanbul ignore next */ || this;\r\n        _this.topRule = topRule;\r\n        _this.occurrence = occurrence;\r\n        _this.result = {\r\n            token: undefined,\r\n            occurrence: undefined,\r\n            isEndOfRule: undefined\r\n        };\r\n        return _this;\r\n    }\r\n    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\r\n        this.walk(this.topRule);\r\n        return this.result;\r\n    };\r\n    return AbstractNextTerminalAfterProductionWalker;\r\n}(rest_1.RestWalker));\r\nexports.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;\r\nvar NextTerminalAfterManyWalker = /** @class */ (function (_super) {\r\n    __extends(NextTerminalAfterManyWalker, _super);\r\n    function NextTerminalAfterManyWalker() {\r\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\r\n    }\r\n    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\r\n        if (manyProd.idx === this.occurrence) {\r\n            var firstAfterMany = utils_1.first(currRest.concat(prevRest));\r\n            this.result.isEndOfRule = firstAfterMany === undefined;\r\n            if (firstAfterMany instanceof gast_public_1.Terminal) {\r\n                this.result.token = firstAfterMany.terminalType;\r\n                this.result.occurrence = firstAfterMany.idx;\r\n            }\r\n        }\r\n        else {\r\n            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\r\n        }\r\n    };\r\n    return NextTerminalAfterManyWalker;\r\n}(AbstractNextTerminalAfterProductionWalker));\r\nexports.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;\r\nvar NextTerminalAfterManySepWalker = /** @class */ (function (_super) {\r\n    __extends(NextTerminalAfterManySepWalker, _super);\r\n    function NextTerminalAfterManySepWalker() {\r\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\r\n    }\r\n    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\r\n        if (manySepProd.idx === this.occurrence) {\r\n            var firstAfterManySep = utils_1.first(currRest.concat(prevRest));\r\n            this.result.isEndOfRule = firstAfterManySep === undefined;\r\n            if (firstAfterManySep instanceof gast_public_1.Terminal) {\r\n                this.result.token = firstAfterManySep.terminalType;\r\n                this.result.occurrence = firstAfterManySep.idx;\r\n            }\r\n        }\r\n        else {\r\n            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\r\n        }\r\n    };\r\n    return NextTerminalAfterManySepWalker;\r\n}(AbstractNextTerminalAfterProductionWalker));\r\nexports.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;\r\nvar NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {\r\n    __extends(NextTerminalAfterAtLeastOneWalker, _super);\r\n    function NextTerminalAfterAtLeastOneWalker() {\r\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\r\n    }\r\n    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\r\n        if (atLeastOneProd.idx === this.occurrence) {\r\n            var firstAfterAtLeastOne = utils_1.first(currRest.concat(prevRest));\r\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\r\n            if (firstAfterAtLeastOne instanceof gast_public_1.Terminal) {\r\n                this.result.token = firstAfterAtLeastOne.terminalType;\r\n                this.result.occurrence = firstAfterAtLeastOne.idx;\r\n            }\r\n        }\r\n        else {\r\n            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\r\n        }\r\n    };\r\n    return NextTerminalAfterAtLeastOneWalker;\r\n}(AbstractNextTerminalAfterProductionWalker));\r\nexports.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;\r\n// TODO: reduce code duplication in the AfterWalkers\r\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {\r\n    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\r\n    function NextTerminalAfterAtLeastOneSepWalker() {\r\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\r\n    }\r\n    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\r\n        if (atleastOneSepProd.idx === this.occurrence) {\r\n            var firstAfterfirstAfterAtLeastOneSep = utils_1.first(currRest.concat(prevRest));\r\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\r\n            if (firstAfterfirstAfterAtLeastOneSep instanceof gast_public_1.Terminal) {\r\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\r\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\r\n            }\r\n        }\r\n        else {\r\n            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\r\n        }\r\n    };\r\n    return NextTerminalAfterAtLeastOneSepWalker;\r\n}(AbstractNextTerminalAfterProductionWalker));\r\nexports.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;\r\nfunction possiblePathsFrom(targetDef, maxLength, currPath) {\r\n    if (currPath === void 0) { currPath = []; }\r\n    // avoid side effects\r\n    currPath = utils_1.cloneArr(currPath);\r\n    var result = [];\r\n    var i = 0;\r\n    // TODO: avoid inner funcs\r\n    function remainingPathWith(nextDef) {\r\n        return nextDef.concat(utils_1.drop(targetDef, i + 1));\r\n    }\r\n    // TODO: avoid inner funcs\r\n    function getAlternativesForProd(definition) {\r\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\r\n        return result.concat(alternatives);\r\n    }\r\n    /**\r\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\r\n     * following (rest) of the targetDef.\r\n     *\r\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\r\n     * the optional production.\r\n     */\r\n    while (currPath.length < maxLength && i < targetDef.length) {\r\n        var prod = targetDef[i];\r\n        /* istanbul ignore else */\r\n        if (prod instanceof gast_public_1.Alternative) {\r\n            return getAlternativesForProd(prod.definition);\r\n        }\r\n        else if (prod instanceof gast_public_1.NonTerminal) {\r\n            return getAlternativesForProd(prod.definition);\r\n        }\r\n        else if (prod instanceof gast_public_1.Option) {\r\n            result = getAlternativesForProd(prod.definition);\r\n        }\r\n        else if (prod instanceof gast_public_1.RepetitionMandatory) {\r\n            var newDef = prod.definition.concat([\r\n                new gast_public_1.Repetition({\r\n                    definition: prod.definition\r\n                })\r\n            ]);\r\n            return getAlternativesForProd(newDef);\r\n        }\r\n        else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\r\n            var newDef = [\r\n                new gast_public_1.Alternative({ definition: prod.definition }),\r\n                new gast_public_1.Repetition({\r\n                    definition: [new gast_public_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)\r\n                })\r\n            ];\r\n            return getAlternativesForProd(newDef);\r\n        }\r\n        else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\r\n            var newDef = prod.definition.concat([\r\n                new gast_public_1.Repetition({\r\n                    definition: [new gast_public_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)\r\n                })\r\n            ]);\r\n            result = getAlternativesForProd(newDef);\r\n        }\r\n        else if (prod instanceof gast_public_1.Repetition) {\r\n            var newDef = prod.definition.concat([\r\n                new gast_public_1.Repetition({\r\n                    definition: prod.definition\r\n                })\r\n            ]);\r\n            result = getAlternativesForProd(newDef);\r\n        }\r\n        else if (prod instanceof gast_public_1.Alternation) {\r\n            utils_1.forEach(prod.definition, function (currAlt) {\r\n                // TODO: this is a limited check for empty alternatives\r\n                //   It would prevent a common case of infinite loops during parser initialization.\r\n                //   However **in-directly** empty alternatives may still cause issues.\r\n                if (utils_1.isEmpty(currAlt.definition) === false) {\r\n                    result = getAlternativesForProd(currAlt.definition);\r\n                }\r\n            });\r\n            return result;\r\n        }\r\n        else if (prod instanceof gast_public_1.Terminal) {\r\n            currPath.push(prod.terminalType);\r\n        }\r\n        else {\r\n            throw Error(\"non exhaustive match\");\r\n        }\r\n        i++;\r\n    }\r\n    result.push({\r\n        partialPath: currPath,\r\n        suffixDef: utils_1.drop(targetDef, i)\r\n    });\r\n    return result;\r\n}\r\nexports.possiblePathsFrom = possiblePathsFrom;\r\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\r\n    var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\r\n    // to avoid creating a new Array each time.\r\n    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\r\n    var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\r\n    var foundCompletePath = false;\r\n    var tokenVectorLength = tokenVector.length;\r\n    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\r\n    var result = [];\r\n    var possiblePaths = [];\r\n    possiblePaths.push({\r\n        idx: -1,\r\n        def: initialDef,\r\n        ruleStack: [],\r\n        occurrenceStack: []\r\n    });\r\n    while (!utils_1.isEmpty(possiblePaths)) {\r\n        var currPath = possiblePaths.pop();\r\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\r\n        if (currPath === EXIT_ALTERNATIVE) {\r\n            if (foundCompletePath &&\r\n                utils_1.last(possiblePaths).idx <= minimalAlternativesIndex) {\r\n                // remove irrelevant alternative\r\n                possiblePaths.pop();\r\n            }\r\n            continue;\r\n        }\r\n        var currDef = currPath.def;\r\n        var currIdx = currPath.idx;\r\n        var currRuleStack = currPath.ruleStack;\r\n        var currOccurrenceStack = currPath.occurrenceStack;\r\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\r\n        if (utils_1.isEmpty(currDef)) {\r\n            continue;\r\n        }\r\n        var prod = currDef[0];\r\n        /* istanbul ignore else */\r\n        if (prod === EXIT_NON_TERMINAL) {\r\n            var nextPath = {\r\n                idx: currIdx,\r\n                def: utils_1.drop(currDef),\r\n                ruleStack: utils_1.dropRight(currRuleStack),\r\n                occurrenceStack: utils_1.dropRight(currOccurrenceStack)\r\n            };\r\n            possiblePaths.push(nextPath);\r\n        }\r\n        else if (prod instanceof gast_public_1.Terminal) {\r\n            /* istanbul ignore else */\r\n            if (currIdx < tokenVectorLength - 1) {\r\n                var nextIdx = currIdx + 1;\r\n                var actualToken = tokenVector[nextIdx];\r\n                if (tokMatcher(actualToken, prod.terminalType)) {\r\n                    var nextPath = {\r\n                        idx: nextIdx,\r\n                        def: utils_1.drop(currDef),\r\n                        ruleStack: currRuleStack,\r\n                        occurrenceStack: currOccurrenceStack\r\n                    };\r\n                    possiblePaths.push(nextPath);\r\n                }\r\n                // end of the line\r\n            }\r\n            else if (currIdx === tokenVectorLength - 1) {\r\n                // IGNORE ABOVE ELSE\r\n                result.push({\r\n                    nextTokenType: prod.terminalType,\r\n                    nextTokenOccurrence: prod.idx,\r\n                    ruleStack: currRuleStack,\r\n                    occurrenceStack: currOccurrenceStack\r\n                });\r\n                foundCompletePath = true;\r\n            }\r\n            else {\r\n                throw Error(\"non exhaustive match\");\r\n            }\r\n        }\r\n        else if (prod instanceof gast_public_1.NonTerminal) {\r\n            var newRuleStack = utils_1.cloneArr(currRuleStack);\r\n            newRuleStack.push(prod.nonTerminalName);\r\n            var newOccurrenceStack = utils_1.cloneArr(currOccurrenceStack);\r\n            newOccurrenceStack.push(prod.idx);\r\n            var nextPath = {\r\n                idx: currIdx,\r\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, utils_1.drop(currDef)),\r\n                ruleStack: newRuleStack,\r\n                occurrenceStack: newOccurrenceStack\r\n            };\r\n            possiblePaths.push(nextPath);\r\n        }\r\n        else if (prod instanceof gast_public_1.Option) {\r\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n            var nextPathWithout = {\r\n                idx: currIdx,\r\n                def: utils_1.drop(currDef),\r\n                ruleStack: currRuleStack,\r\n                occurrenceStack: currOccurrenceStack\r\n            };\r\n            possiblePaths.push(nextPathWithout);\r\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\r\n            possiblePaths.push(EXIT_ALTERNATIVE);\r\n            var nextPathWith = {\r\n                idx: currIdx,\r\n                def: prod.definition.concat(utils_1.drop(currDef)),\r\n                ruleStack: currRuleStack,\r\n                occurrenceStack: currOccurrenceStack\r\n            };\r\n            possiblePaths.push(nextPathWith);\r\n        }\r\n        else if (prod instanceof gast_public_1.RepetitionMandatory) {\r\n            // TODO:(THE NEW operators here take a while...) (convert once?)\r\n            var secondIteration = new gast_public_1.Repetition({\r\n                definition: prod.definition,\r\n                idx: prod.idx\r\n            });\r\n            var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));\r\n            var nextPath = {\r\n                idx: currIdx,\r\n                def: nextDef,\r\n                ruleStack: currRuleStack,\r\n                occurrenceStack: currOccurrenceStack\r\n            };\r\n            possiblePaths.push(nextPath);\r\n        }\r\n        else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\r\n            // TODO:(THE NEW operators here take a while...) (convert once?)\r\n            var separatorGast = new gast_public_1.Terminal({\r\n                terminalType: prod.separator\r\n            });\r\n            var secondIteration = new gast_public_1.Repetition({\r\n                definition: [separatorGast].concat(prod.definition),\r\n                idx: prod.idx\r\n            });\r\n            var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));\r\n            var nextPath = {\r\n                idx: currIdx,\r\n                def: nextDef,\r\n                ruleStack: currRuleStack,\r\n                occurrenceStack: currOccurrenceStack\r\n            };\r\n            possiblePaths.push(nextPath);\r\n        }\r\n        else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\r\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n            var nextPathWithout = {\r\n                idx: currIdx,\r\n                def: utils_1.drop(currDef),\r\n                ruleStack: currRuleStack,\r\n                occurrenceStack: currOccurrenceStack\r\n            };\r\n            possiblePaths.push(nextPathWithout);\r\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\r\n            possiblePaths.push(EXIT_ALTERNATIVE);\r\n            var separatorGast = new gast_public_1.Terminal({\r\n                terminalType: prod.separator\r\n            });\r\n            var nthRepetition = new gast_public_1.Repetition({\r\n                definition: [separatorGast].concat(prod.definition),\r\n                idx: prod.idx\r\n            });\r\n            var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));\r\n            var nextPathWith = {\r\n                idx: currIdx,\r\n                def: nextDef,\r\n                ruleStack: currRuleStack,\r\n                occurrenceStack: currOccurrenceStack\r\n            };\r\n            possiblePaths.push(nextPathWith);\r\n        }\r\n        else if (prod instanceof gast_public_1.Repetition) {\r\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n            var nextPathWithout = {\r\n                idx: currIdx,\r\n                def: utils_1.drop(currDef),\r\n                ruleStack: currRuleStack,\r\n                occurrenceStack: currOccurrenceStack\r\n            };\r\n            possiblePaths.push(nextPathWithout);\r\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\r\n            possiblePaths.push(EXIT_ALTERNATIVE);\r\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\r\n            var nthRepetition = new gast_public_1.Repetition({\r\n                definition: prod.definition,\r\n                idx: prod.idx\r\n            });\r\n            var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));\r\n            var nextPathWith = {\r\n                idx: currIdx,\r\n                def: nextDef,\r\n                ruleStack: currRuleStack,\r\n                occurrenceStack: currOccurrenceStack\r\n            };\r\n            possiblePaths.push(nextPathWith);\r\n        }\r\n        else if (prod instanceof gast_public_1.Alternation) {\r\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n            for (var i = prod.definition.length - 1; i >= 0; i--) {\r\n                var currAlt = prod.definition[i];\r\n                var currAltPath = {\r\n                    idx: currIdx,\r\n                    def: currAlt.definition.concat(utils_1.drop(currDef)),\r\n                    ruleStack: currRuleStack,\r\n                    occurrenceStack: currOccurrenceStack\r\n                };\r\n                possiblePaths.push(currAltPath);\r\n                possiblePaths.push(EXIT_ALTERNATIVE);\r\n            }\r\n        }\r\n        else if (prod instanceof gast_public_1.Alternative) {\r\n            possiblePaths.push({\r\n                idx: currIdx,\r\n                def: prod.definition.concat(utils_1.drop(currDef)),\r\n                ruleStack: currRuleStack,\r\n                occurrenceStack: currOccurrenceStack\r\n            });\r\n        }\r\n        else if (prod instanceof gast_public_1.Rule) {\r\n            // last because we should only encounter at most a single one of these per invocation.\r\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\r\n        }\r\n        else {\r\n            throw Error(\"non exhaustive match\");\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.nextPossibleTokensAfter = nextPossibleTokensAfter;\r\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\r\n    var newRuleStack = utils_1.cloneArr(currRuleStack);\r\n    newRuleStack.push(topRule.name);\r\n    var newCurrOccurrenceStack = utils_1.cloneArr(currOccurrenceStack);\r\n    // top rule is always assumed to have been called with occurrence index 1\r\n    newCurrOccurrenceStack.push(1);\r\n    return {\r\n        idx: currIdx,\r\n        def: topRule.definition,\r\n        ruleStack: newRuleStack,\r\n        occurrenceStack: newCurrOccurrenceStack\r\n    };\r\n}\r\n//# sourceMappingURL=interpreter.js.map"]},"metadata":{},"sourceType":"script"}