{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LexerAdapter = void 0;\n\nvar parser_1 = require(\"../parser\");\n/**\r\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\r\n *\r\n * This could be generalized to support other kinds of lexers, e.g.\r\n * - Just in Time Lexing / Lexer-Less parsing.\r\n * - Streaming Lexer.\r\n */\n\n\nvar LexerAdapter =\n/** @class */\nfunction () {\n  function LexerAdapter() {}\n\n  LexerAdapter.prototype.initLexerAdapter = function () {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  };\n\n  Object.defineProperty(LexerAdapter.prototype, \"input\", {\n    get: function () {\n      return this.tokVector;\n    },\n    set: function (newInput) {\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      if (this.selfAnalysisDone !== true) {\n        throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n      } // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n\n\n      this.reset();\n      this.tokVector = newInput;\n      this.tokVectorLength = newInput.length;\n    },\n    enumerable: false,\n    configurable: true\n  }); // skips a token and returns the next token\n\n  LexerAdapter.prototype.SKIP_TOKEN = function () {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return parser_1.END_OF_FILE;\n    }\n  }; // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n\n\n  LexerAdapter.prototype.LA = function (howMuch) {\n    var soughtIdx = this.currIdx + howMuch;\n\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return parser_1.END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  };\n\n  LexerAdapter.prototype.consumeToken = function () {\n    this.currIdx++;\n  };\n\n  LexerAdapter.prototype.exportLexerState = function () {\n    return this.currIdx;\n  };\n\n  LexerAdapter.prototype.importLexerState = function (newState) {\n    this.currIdx = newState;\n  };\n\n  LexerAdapter.prototype.resetLexerState = function () {\n    this.currIdx = -1;\n  };\n\n  LexerAdapter.prototype.moveToTerminatedState = function () {\n    this.currIdx = this.tokVector.length - 1;\n  };\n\n  LexerAdapter.prototype.getLexerPosition = function () {\n    return this.exportLexerState();\n  };\n\n  return LexerAdapter;\n}();\n\nexports.LexerAdapter = LexerAdapter;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/lexer_adapter.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AAIA;;;;;;AAMG;;;AACH,IAAA,YAAA;AAAA;AAAA,YAAA;AAAA,WAAA,YAAA,GAAA,CA0EC;;AArEC,EAAA,YAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,YAAA;AACE,SAAK,SAAL,GAAiB,EAAjB;AACA,SAAK,eAAL,GAAuB,CAAvB;AACA,SAAK,OAAL,GAAe,CAAC,CAAhB;AACD,GAJD;;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,YAAA,CAAA,SAAJ,EAAI,OAAJ,EAAS;SAeT,YAAA;AACE,aAAO,KAAK,SAAZ;AACD,KAjBQ;SAAT,UAAU,QAAV,EAA4B;AAC1B;AACA;AACA,UAAI,KAAK,gBAAL,KAA0B,IAA9B,EAAoC;AAClC,cAAM,KAAK,CACT,kFADS,CAAX;AAGD,OAPyB,CAQ1B;AACA;;;AACA,WAAK,KAAL;AACA,WAAK,SAAL,GAAiB,QAAjB;AACA,WAAK,eAAL,GAAuB,QAAQ,CAAC,MAAhC;AACD,KAbQ;qBAAA;;AAAA,GAAT,EAXF,CA8BE;;AACA,EAAA,YAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AACE,QAAI,KAAK,OAAL,IAAgB,KAAK,SAAL,CAAe,MAAf,GAAwB,CAA5C,EAA+C;AAC7C,WAAK,YAAL;AACA,aAAO,KAAK,EAAL,CAAQ,CAAR,CAAP;AACD,KAHD,MAGO;AACL,aAAO,QAAA,CAAA,WAAP;AACD;AACF,GAPD,CA/BF,CAwCE;AACA;;;AACA,EAAA,YAAA,CAAA,SAAA,CAAA,EAAA,GAAA,UAAwB,OAAxB,EAAuC;AACrC,QAAM,SAAS,GAAG,KAAK,OAAL,GAAe,OAAjC;;AACA,QAAI,SAAS,GAAG,CAAZ,IAAiB,KAAK,eAAL,IAAwB,SAA7C,EAAwD;AACtD,aAAO,QAAA,CAAA,WAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAK,SAAL,CAAe,SAAf,CAAP;AACD;AACF,GAPD;;AASA,EAAA,YAAA,CAAA,SAAA,CAAA,YAAA,GAAA,YAAA;AACE,SAAK,OAAL;AACD,GAFD;;AAIA,EAAA,YAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,YAAA;AACE,WAAO,KAAK,OAAZ;AACD,GAFD;;AAIA,EAAA,YAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAsC,QAAtC,EAAsD;AACpD,SAAK,OAAL,GAAe,QAAf;AACD,GAFD;;AAIA,EAAA,YAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,SAAK,OAAL,GAAe,CAAC,CAAhB;AACD,GAFD;;AAIA,EAAA,YAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,YAAA;AACE,SAAK,OAAL,GAAe,KAAK,SAAL,CAAe,MAAf,GAAwB,CAAvC;AACD,GAFD;;AAIA,EAAA,YAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,YAAA;AACE,WAAO,KAAK,gBAAL,EAAP;AACD,GAFD;;AAGF,SAAA,YAAA;AAAC,CA1ED,EAAA;;AAAa,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LexerAdapter = void 0;\r\nvar parser_1 = require(\"../parser\");\r\n/**\r\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\r\n *\r\n * This could be generalized to support other kinds of lexers, e.g.\r\n * - Just in Time Lexing / Lexer-Less parsing.\r\n * - Streaming Lexer.\r\n */\r\nvar LexerAdapter = /** @class */ (function () {\r\n    function LexerAdapter() {\r\n    }\r\n    LexerAdapter.prototype.initLexerAdapter = function () {\r\n        this.tokVector = [];\r\n        this.tokVectorLength = 0;\r\n        this.currIdx = -1;\r\n    };\r\n    Object.defineProperty(LexerAdapter.prototype, \"input\", {\r\n        get: function () {\r\n            return this.tokVector;\r\n        },\r\n        set: function (newInput) {\r\n            // @ts-ignore - `this parameter` not supported in setters/getters\r\n            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\r\n            if (this.selfAnalysisDone !== true) {\r\n                throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\r\n            }\r\n            // @ts-ignore - `this parameter` not supported in setters/getters\r\n            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\r\n            this.reset();\r\n            this.tokVector = newInput;\r\n            this.tokVectorLength = newInput.length;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // skips a token and returns the next token\r\n    LexerAdapter.prototype.SKIP_TOKEN = function () {\r\n        if (this.currIdx <= this.tokVector.length - 2) {\r\n            this.consumeToken();\r\n            return this.LA(1);\r\n        }\r\n        else {\r\n            return parser_1.END_OF_FILE;\r\n        }\r\n    };\r\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\r\n    // or lexers dependent on parser context.\r\n    LexerAdapter.prototype.LA = function (howMuch) {\r\n        var soughtIdx = this.currIdx + howMuch;\r\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\r\n            return parser_1.END_OF_FILE;\r\n        }\r\n        else {\r\n            return this.tokVector[soughtIdx];\r\n        }\r\n    };\r\n    LexerAdapter.prototype.consumeToken = function () {\r\n        this.currIdx++;\r\n    };\r\n    LexerAdapter.prototype.exportLexerState = function () {\r\n        return this.currIdx;\r\n    };\r\n    LexerAdapter.prototype.importLexerState = function (newState) {\r\n        this.currIdx = newState;\r\n    };\r\n    LexerAdapter.prototype.resetLexerState = function () {\r\n        this.currIdx = -1;\r\n    };\r\n    LexerAdapter.prototype.moveToTerminatedState = function () {\r\n        this.currIdx = this.tokVector.length - 1;\r\n    };\r\n    LexerAdapter.prototype.getLexerPosition = function () {\r\n        return this.exportLexerState();\r\n    };\r\n    return LexerAdapter;\r\n}());\r\nexports.LexerAdapter = LexerAdapter;\r\n//# sourceMappingURL=lexer_adapter.js.map"]},"metadata":{},"sourceType":"script"}