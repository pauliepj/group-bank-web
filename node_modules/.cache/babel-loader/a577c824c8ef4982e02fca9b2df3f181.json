{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\n\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\n\nvar lexer_1 = require(\"./lexer\");\n\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\n\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n\n  try {\n    var ast = reg_exp_parser_1.getRegExpAst(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        utils_1.PRINT_WARNING(\"\" + exports.failedOptimizationPrefixMsg + (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n\n      utils_1.PRINT_ERROR(exports.failedOptimizationPrefixMsg + \"\\n\" + (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") + (\"\\tUsing the regexp-to-ast library version: \" + regexp_to_ast_1.VERSION + \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n\n  return [];\n}\n\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\n\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n\n      break;\n\n    case \"Alternative\":\n      var terms = ast.value;\n\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i]; // skip terms that cannot effect the first char results\n\n        switch (term.type) {\n          case \"EndAnchor\": // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n\n          case \"GroupBackReference\": // assertions do not affect potential starting codes\n\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n\n        var atom = term;\n\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n\n            utils_1.forEach(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code; // cannot optimize when ignoreCase is\n\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                } // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                    // handle unoptimized values\n                    for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\n                      addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                    } // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n\n\n                    if (range.to >= lexer_1.minOptimizationVal) {\n                      var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;\n                      var maxUnOptVal = range.to;\n                      var minOptIdx = lexer_1.charCodeToOptimizedIndex(minUnOptVal);\n                      var maxOptIdx = lexer_1.charCodeToOptimizedIndex(maxUnOptVal);\n\n                      for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                        result[currOptIdx] = currOptIdx;\n                      }\n                    }\n                  }\n              }\n            });\n            break;\n\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n\n          /* istanbul ignore next */\n\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        } // reached a mandatory production, no more **start** codes can be found on this alternative\n\n\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n\n        if ( // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n\n      break;\n\n    /* istanbul ignore next */\n\n    default:\n      throw Error(\"non exhaustive match!\");\n  } // console.log(Object.keys(result).length)\n\n\n  return utils_1.values(result);\n}\n\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\n\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\n\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n\n  if (upperChar !== char) {\n    var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n\n    if (lowerChar !== char) {\n      var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\n\nfunction findCode(setNode, targetCharCodes) {\n  return utils_1.find(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return utils_1.contains(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return utils_1.find(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\n\nfunction isWholeOptional(ast) {\n  if (ast.quantifier && ast.quantifier.atLeast === 0) {\n    return true;\n  }\n\n  if (!ast.value) {\n    return false;\n  }\n\n  return utils_1.isArray(ast.value) ? utils_1.every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\n\nvar CharCodeFinder =\n/** @class */\nfunction (_super) {\n  __extends(CharCodeFinder, _super);\n\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    } // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n\n\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n\n    _super.prototype.visitChildren.call(this, node);\n  };\n\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if (utils_1.contains(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n\n  return CharCodeFinder;\n}(regexp_to_ast_1.BaseRegExpVisitor);\n\nfunction canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = reg_exp_parser_1.getRegExpAst(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return utils_1.find(pattern, function (char) {\n      return utils_1.contains(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}\n\nexports.canMatchCharCode = canMatchCharCode;","map":{"version":3,"sources":["../../../src/scan/reg_exp.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\r\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\r\nvar utils_1 = require(\"@chevrotain/utils\");\r\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\r\nvar lexer_1 = require(\"./lexer\");\r\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\r\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\r\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\r\n    if (ensureOptimizations === void 0) { ensureOptimizations = false; }\r\n    try {\r\n        var ast = reg_exp_parser_1.getRegExpAst(regExp);\r\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\r\n        return firstChars;\r\n    }\r\n    catch (e) {\r\n        /* istanbul ignore next */\r\n        // Testing this relies on the regexp-to-ast library having a bug... */\r\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\r\n        if (e.message === complementErrorMessage) {\r\n            if (ensureOptimizations) {\r\n                utils_1.PRINT_WARNING(\"\" + exports.failedOptimizationPrefixMsg +\r\n                    (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") +\r\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\r\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\r\n                    \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\r\n            }\r\n        }\r\n        else {\r\n            var msgSuffix = \"\";\r\n            if (ensureOptimizations) {\r\n                msgSuffix =\r\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\r\n                        \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\r\n            }\r\n            utils_1.PRINT_ERROR(exports.failedOptimizationPrefixMsg + \"\\n\" +\r\n                (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") +\r\n                (\"\\tUsing the regexp-to-ast library version: \" + regexp_to_ast_1.VERSION + \"\\n\") +\r\n                \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\r\n                msgSuffix);\r\n        }\r\n    }\r\n    return [];\r\n}\r\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\r\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\r\n    switch (ast.type) {\r\n        case \"Disjunction\":\r\n            for (var i = 0; i < ast.value.length; i++) {\r\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\r\n            }\r\n            break;\r\n        case \"Alternative\":\r\n            var terms = ast.value;\r\n            for (var i = 0; i < terms.length; i++) {\r\n                var term = terms[i];\r\n                // skip terms that cannot effect the first char results\r\n                switch (term.type) {\r\n                    case \"EndAnchor\":\r\n                    // A group back reference cannot affect potential starting char.\r\n                    // because if a back reference is the first production than automatically\r\n                    // the group being referenced has had to come BEFORE so its codes have already been added\r\n                    case \"GroupBackReference\":\r\n                    // assertions do not affect potential starting codes\r\n                    case \"Lookahead\":\r\n                    case \"NegativeLookahead\":\r\n                    case \"StartAnchor\":\r\n                    case \"WordBoundary\":\r\n                    case \"NonWordBoundary\":\r\n                        continue;\r\n                }\r\n                var atom = term;\r\n                switch (atom.type) {\r\n                    case \"Character\":\r\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\r\n                        break;\r\n                    case \"Set\":\r\n                        if (atom.complement === true) {\r\n                            throw Error(complementErrorMessage);\r\n                        }\r\n                        utils_1.forEach(atom.value, function (code) {\r\n                            if (typeof code === \"number\") {\r\n                                addOptimizedIdxToResult(code, result, ignoreCase);\r\n                            }\r\n                            else {\r\n                                // range\r\n                                var range = code;\r\n                                // cannot optimize when ignoreCase is\r\n                                if (ignoreCase === true) {\r\n                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\r\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\r\n                                    }\r\n                                }\r\n                                // Optimization (2 orders of magnitude less work for very large ranges)\r\n                                else {\r\n                                    // handle unoptimized values\r\n                                    for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\r\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\r\n                                    }\r\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\r\n                                    if (range.to >= lexer_1.minOptimizationVal) {\r\n                                        var minUnOptVal = range.from >= lexer_1.minOptimizationVal\r\n                                            ? range.from\r\n                                            : lexer_1.minOptimizationVal;\r\n                                        var maxUnOptVal = range.to;\r\n                                        var minOptIdx = lexer_1.charCodeToOptimizedIndex(minUnOptVal);\r\n                                        var maxOptIdx = lexer_1.charCodeToOptimizedIndex(maxUnOptVal);\r\n                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\r\n                                            result[currOptIdx] = currOptIdx;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                        break;\r\n                    case \"Group\":\r\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\r\n                        break;\r\n                    /* istanbul ignore next */\r\n                    default:\r\n                        throw Error(\"Non Exhaustive Match\");\r\n                }\r\n                // reached a mandatory production, no more **start** codes can be found on this alternative\r\n                var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\r\n                if (\r\n                // A group may be optional due to empty contents /(?:)/\r\n                // or if everything inside it is optional /((a)?)/\r\n                (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\r\n                    // If this term is not a group it may only be optional if it has an optional quantifier\r\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw Error(\"non exhaustive match!\");\r\n    }\r\n    // console.log(Object.keys(result).length)\r\n    return utils_1.values(result);\r\n}\r\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\r\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\r\n    var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(code);\r\n    result[optimizedCharIdx] = optimizedCharIdx;\r\n    if (ignoreCase === true) {\r\n        handleIgnoreCase(code, result);\r\n    }\r\n}\r\nfunction handleIgnoreCase(code, result) {\r\n    var char = String.fromCharCode(code);\r\n    var upperChar = char.toUpperCase();\r\n    /* istanbul ignore else */\r\n    if (upperChar !== char) {\r\n        var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(upperChar.charCodeAt(0));\r\n        result[optimizedCharIdx] = optimizedCharIdx;\r\n    }\r\n    else {\r\n        var lowerChar = char.toLowerCase();\r\n        if (lowerChar !== char) {\r\n            var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\r\n            result[optimizedCharIdx] = optimizedCharIdx;\r\n        }\r\n    }\r\n}\r\nfunction findCode(setNode, targetCharCodes) {\r\n    return utils_1.find(setNode.value, function (codeOrRange) {\r\n        if (typeof codeOrRange === \"number\") {\r\n            return utils_1.contains(targetCharCodes, codeOrRange);\r\n        }\r\n        else {\r\n            // range\r\n            var range_1 = codeOrRange;\r\n            return (utils_1.find(targetCharCodes, function (targetCode) { return range_1.from <= targetCode && targetCode <= range_1.to; }) !== undefined);\r\n        }\r\n    });\r\n}\r\nfunction isWholeOptional(ast) {\r\n    if (ast.quantifier && ast.quantifier.atLeast === 0) {\r\n        return true;\r\n    }\r\n    if (!ast.value) {\r\n        return false;\r\n    }\r\n    return utils_1.isArray(ast.value)\r\n        ? utils_1.every(ast.value, isWholeOptional)\r\n        : isWholeOptional(ast.value);\r\n}\r\nvar CharCodeFinder = /** @class */ (function (_super) {\r\n    __extends(CharCodeFinder, _super);\r\n    function CharCodeFinder(targetCharCodes) {\r\n        var _this = _super.call(this) || this;\r\n        _this.targetCharCodes = targetCharCodes;\r\n        _this.found = false;\r\n        return _this;\r\n    }\r\n    CharCodeFinder.prototype.visitChildren = function (node) {\r\n        // No need to keep looking...\r\n        if (this.found === true) {\r\n            return;\r\n        }\r\n        // switch lookaheads as they do not actually consume any characters thus\r\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\r\n        switch (node.type) {\r\n            case \"Lookahead\":\r\n                this.visitLookahead(node);\r\n                return;\r\n            case \"NegativeLookahead\":\r\n                this.visitNegativeLookahead(node);\r\n                return;\r\n        }\r\n        _super.prototype.visitChildren.call(this, node);\r\n    };\r\n    CharCodeFinder.prototype.visitCharacter = function (node) {\r\n        if (utils_1.contains(this.targetCharCodes, node.value)) {\r\n            this.found = true;\r\n        }\r\n    };\r\n    CharCodeFinder.prototype.visitSet = function (node) {\r\n        if (node.complement) {\r\n            if (findCode(node, this.targetCharCodes) === undefined) {\r\n                this.found = true;\r\n            }\r\n        }\r\n        else {\r\n            if (findCode(node, this.targetCharCodes) !== undefined) {\r\n                this.found = true;\r\n            }\r\n        }\r\n    };\r\n    return CharCodeFinder;\r\n}(regexp_to_ast_1.BaseRegExpVisitor));\r\nfunction canMatchCharCode(charCodes, pattern) {\r\n    if (pattern instanceof RegExp) {\r\n        var ast = reg_exp_parser_1.getRegExpAst(pattern);\r\n        var charCodeFinder = new CharCodeFinder(charCodes);\r\n        charCodeFinder.visit(ast);\r\n        return charCodeFinder.found;\r\n    }\r\n    else {\r\n        return (utils_1.find(pattern, function (char) {\r\n            return utils_1.contains(charCodes, char.charCodeAt(0));\r\n        }) !== undefined);\r\n    }\r\n}\r\nexports.canMatchCharCode = canMatchCharCode;\r\n//# sourceMappingURL=reg_exp.js.map"]},"metadata":{},"sourceType":"script"}