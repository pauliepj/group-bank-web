{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar gast_public_1 = require(\"./gast/gast_public\");\n\nvar gast_1 = require(\"./gast/gast\");\n\nfunction first(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof gast_public_1.NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first(prod.referencedRule);\n  } else if (prod instanceof gast_public_1.Terminal) {\n    return firstForTerminal(prod);\n  } else if (gast_1.isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (gast_1.isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.first = first;\n\nfunction firstForSequence(prod) {\n  var firstSet = [];\n  var seq = prod.definition;\n  var nextSubProdIdx = 0;\n  var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  var currSubProd; // so we enter the loop at least once (if the definition is not empty\n\n  var isLastInnerProdOptional = true; // scan a sequence until it's end or until we have found a NONE optional production in it\n\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = gast_1.isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n\n  return utils_1.uniq(firstSet);\n}\n\nexports.firstForSequence = firstForSequence;\n\nfunction firstForBranching(prod) {\n  var allAlternativesFirsts = utils_1.map(prod.definition, function (innerProd) {\n    return first(innerProd);\n  });\n  return utils_1.uniq(utils_1.flatten(allAlternativesFirsts));\n}\n\nexports.firstForBranching = firstForBranching;\n\nfunction firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}\n\nexports.firstForTerminal = firstForTerminal;","map":{"version":3,"sources":["../../../../src/parse/grammar/first.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAGA,SAAgB,KAAhB,CAAsB,IAAtB,EAAuC;AACrC;AACA,MAAI,IAAI,YAAY,aAAA,CAAA,WAApB,EAAiC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAO,KAAK,CAAe,IAAK,CAAC,cAArB,CAAZ;AACD,GAVD,MAUO,IAAI,IAAI,YAAY,aAAA,CAAA,QAApB,EAA8B;AACnC,WAAO,gBAAgB,CAAW,IAAX,CAAvB;AACD,GAFM,MAEA,IAAI,MAAA,CAAA,cAAA,CAAe,IAAf,CAAJ,EAA0B;AAC/B,WAAO,gBAAgB,CAAqB,IAArB,CAAvB;AACD,GAFM,MAEA,IAAI,MAAA,CAAA,eAAA,CAAgB,IAAhB,CAAJ,EAA2B;AAChC,WAAO,iBAAiB,CAAqB,IAArB,CAAxB;AACD,GAFM,MAEA;AACL,UAAM,KAAK,CAAC,sBAAD,CAAX;AACD;AACF;;AArBD,OAAA,CAAA,KAAA,GAAA,KAAA;;AAuBA,SAAgB,gBAAhB,CAAiC,IAAjC,EAAyD;AACvD,MAAI,QAAQ,GAAgB,EAA5B;AACA,MAAM,GAAG,GAAG,IAAI,CAAC,UAAjB;AACA,MAAI,cAAc,GAAG,CAArB;AACA,MAAI,sBAAsB,GAAG,GAAG,CAAC,MAAJ,GAAa,cAA1C;AACA,MAAI,WAAJ,CALuD,CAMvD;;AACA,MAAI,uBAAuB,GAAG,IAA9B,CAPuD,CAQvD;;AACA,SAAO,sBAAsB,IAAI,uBAAjC,EAA0D;AACxD,IAAA,WAAW,GAAG,GAAG,CAAC,cAAD,CAAjB;AACA,IAAA,uBAAuB,GAAG,MAAA,CAAA,cAAA,CAAe,WAAf,CAA1B;AACA,IAAA,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAAC,WAAD,CAArB,CAAX;AACA,IAAA,cAAc,GAAG,cAAc,GAAG,CAAlC;AACA,IAAA,sBAAsB,GAAG,GAAG,CAAC,MAAJ,GAAa,cAAtC;AACD;;AAED,SAAO,OAAA,CAAA,IAAA,CAAK,QAAL,CAAP;AACD;;AAlBD,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAoBA,SAAgB,iBAAhB,CAAkC,IAAlC,EAA0D;AACxD,MAAM,qBAAqB,GAAkB,OAAA,CAAA,GAAA,CAC3C,IAAI,CAAC,UADsC,EAE3C,UAAC,SAAD,EAAU;AACR,WAAO,KAAK,CAAC,SAAD,CAAZ;AACD,GAJ0C,CAA7C;AAMA,SAAO,OAAA,CAAA,IAAA,CAAK,OAAA,CAAA,OAAA,CAAmB,qBAAnB,CAAL,CAAP;AACD;;AARD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAUA,SAAgB,gBAAhB,CAAiC,QAAjC,EAAmD;AACjD,SAAO,CAAC,QAAQ,CAAC,YAAV,CAAP;AACD;;AAFD,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\r\nvar utils_1 = require(\"@chevrotain/utils\");\r\nvar gast_public_1 = require(\"./gast/gast_public\");\r\nvar gast_1 = require(\"./gast/gast\");\r\nfunction first(prod) {\r\n    /* istanbul ignore else */\r\n    if (prod instanceof gast_public_1.NonTerminal) {\r\n        // this could in theory cause infinite loops if\r\n        // (1) prod A refs prod B.\r\n        // (2) prod B refs prod A\r\n        // (3) AB can match the empty set\r\n        // in other words a cycle where everything is optional so the first will keep\r\n        // looking ahead for the next optional part and will never exit\r\n        // currently there is no safeguard for this unique edge case because\r\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\r\n        return first(prod.referencedRule);\r\n    }\r\n    else if (prod instanceof gast_public_1.Terminal) {\r\n        return firstForTerminal(prod);\r\n    }\r\n    else if (gast_1.isSequenceProd(prod)) {\r\n        return firstForSequence(prod);\r\n    }\r\n    else if (gast_1.isBranchingProd(prod)) {\r\n        return firstForBranching(prod);\r\n    }\r\n    else {\r\n        throw Error(\"non exhaustive match\");\r\n    }\r\n}\r\nexports.first = first;\r\nfunction firstForSequence(prod) {\r\n    var firstSet = [];\r\n    var seq = prod.definition;\r\n    var nextSubProdIdx = 0;\r\n    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\r\n    var currSubProd;\r\n    // so we enter the loop at least once (if the definition is not empty\r\n    var isLastInnerProdOptional = true;\r\n    // scan a sequence until it's end or until we have found a NONE optional production in it\r\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\r\n        currSubProd = seq[nextSubProdIdx];\r\n        isLastInnerProdOptional = gast_1.isOptionalProd(currSubProd);\r\n        firstSet = firstSet.concat(first(currSubProd));\r\n        nextSubProdIdx = nextSubProdIdx + 1;\r\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\r\n    }\r\n    return utils_1.uniq(firstSet);\r\n}\r\nexports.firstForSequence = firstForSequence;\r\nfunction firstForBranching(prod) {\r\n    var allAlternativesFirsts = utils_1.map(prod.definition, function (innerProd) {\r\n        return first(innerProd);\r\n    });\r\n    return utils_1.uniq(utils_1.flatten(allAlternativesFirsts));\r\n}\r\nexports.firstForBranching = firstForBranching;\r\nfunction firstForTerminal(terminal) {\r\n    return [terminal.terminalType];\r\n}\r\nexports.firstForTerminal = firstForTerminal;\r\n//# sourceMappingURL=first.js.map"]},"metadata":{},"sourceType":"script"}